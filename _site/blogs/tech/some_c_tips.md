1. 对size()进行加减操作产生的问题   size()返回的类型时 无符号类型  在默认转换的过程中数据的范围和大小会发生变化。（由于数据类型发生了变化）

2. (1<= A,B <= 10^9) 注意公倍数的范围

3. sizeof (*)指针全部都是 地址长度  32位就是4  64位就是8
   sizeof (int\boole) 数据类型 表示这个类型所用的位数 
   sizeof ([])数组就是指数组长度

4. char *d="0123456789"存放在常量区，是无法修的。char d[]而数组是存放在栈中，是可以修改的。两者区别如下：
  4.1 ”读“ ”写“ 能力
```c
    char *a = "abcd";  //此时"abcd"存放在常量区。通过指针只可以访问字符串常量，而不可以改变它。
    char a[20] = "abcd"； //此时 "abcd"存放在栈。可以通过指针去访问和修改数组内容。
```
	4.2. 赋值时刻

```c
	char *a = "abcd"; //是在编译时就确定了（因为为常量）。
	char a[20] = "abcd"； //在运行时确定
```
	4.3. 存取效率
```c
	char *a = "abcd"; //存于静态存储区。在栈上的数组比指针所指向字符串快。因此慢，如果修改会出现：“Segment Default"
	char a[20] = "abcd"； //存于栈上。快
```
    另外注意：
```c
    char a[] = "01234" //虽然没有指明字符串的长度，但是此时系统已经开好了，就是大小为6：'0' '1' '2' '3' '4' '5' '\0'，
```

	(注意strlen(a)是不计‘\0’ 而sizeof(a)是计算 '\0'的)

5. const 不能修饰后面的*  也是时不存在const * ，所以char const * cp中 const 只能修饰char。而 char * const cp中，const修饰了cp。


6. 下面程序的输出是 4 6 4 6 （g++编译器）

```c
  void test(char*s){
      cout<<sizeof(s)<<endl; // 指针的大小
      cout<<strlen(s)<<endl;
  }
  int main(){
      char *s1="123456";
      char s2[] = "123456";
      test(s1);
      test(s2);
   
  }
```

  [back](../../index.md)
