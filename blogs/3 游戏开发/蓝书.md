[toc]

# unity5游戏开发技术详解与典型案例复习
VR实验室项目组-班元鹏，范宇鹏，季翔，李孟璐，王寿岩，王薇植制作
# 案例一览表
3.4触屏控制飞机
4.2音乐播放器
4.3实例化十个球
4.4触屏控制球体旋转
6.3方向盘控制游艇
6.4抓娃娃机
6.5四驱车开发
6.8运动员骨骼与踢球动画
6.9大炮与炮弹
8.2 3D拾取
8.10人在有雾的山间奔跑
9.3法线贴图使用
9.4镜子开发
9.5真实的水面效果开发
9.6物体变形
10.3模型切割与刀光
10.5角色动画
11.2汽车刹车与轮胎拖痕
11.3自动寻路
13.5用socket开发的模型位置移动的同步
# unity开发的相关问题
[求大神们花2分钟看看我的demo，水平离unity实习级别有多远?应该从那些方面努力](https://www.zhihu.com/question/40107202)
[马上毕业了，我自学了unity，想问问我这种水平毕业后工资能多少。？](https://www.zhihu.com/question/64951492)
[（Unity官方）Unity Technologies 2019 校招面试总结](https://zhuanlan.zhihu.com/p/62331129)    
[自学Unity怎么找到实习呢?](https://www.zhihu.com/question/67815663)
[一道技术美术的面试题](https://blog.csdn.net/kuangben2000/article/details/86697043?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158720424819726867809227%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=158720424819726867809227&biz_id=0&utm_source=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v25-1)

[unity常见面试题目](https://wenku.baidu.com/view/c59f8186f01dc281e43af01b.html)
[Unity3D面试题整合(看完Unity基础知识就掌握差不多了)](http://www.360doc.com/content/18/0423/09/54584204_747989382.shtml)
[史上最全的Unity面试题（含答案）](https://blog.csdn.net/qq_26270779/article/details/53609069?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)
[Unity面试题整理（一）](https://blog.csdn.net/a1191835397/article/details/96474984?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)
[Unity面试题整理（二）](https://blog.csdn.net/a1191835397/article/details/96832851#blob-path)

unity游戏反编译相关的几个帖子：
[1](http://www.xuanyusong.com/archives/2584)
[2](https://www.zhihu.com/question/275984957)
[3](https://zhuanlan.zhihu.com/p/48055816)
[4](https://www.zhihu.com/question/276168633)
[5](https://www.zhihu.com/question/23373100)
[6](https://zhuanlan.zhihu.com/p/107918084)
# 重点知识点总结
## 脚本开发
## UI

# 1. UGUI 控件

11个控件：文本text，两种图片Image和Raw Image，按钮Button，开关Toggle，两种滑杆Slider和Scrollbar，选项框Dropdown，输入框InputField，背景panel，滚动视图Scroll View

## 1.1. Canvas画布

UI元素的绘制顺序通Hierarchy中的顺序一致，重叠则覆盖
三种渲染模式：确定UI是渲染到屏幕空间还是世界空间上。SSO和SSC不会遮挡场景物体，WS会，而且画布可被旋转缩放
SSO：（屏幕）屏幕空间覆盖，默认的，渲染到场景最上层，如果屏幕尺寸或者分辨率发生变化， Canvas也会自动去和变化后的尺寸相适应。
SSC：（相机）屏幕空间摄像，Canvas游戏对象放置在一个预先设置好的摄像机的特定距离外， UI元素通过该摄像机进行渲染。所以使用该模式时应该创建一个摄像机并将其指定给Canvas组件下的Render Camera。改变该摄像机的设置时， UI元素的显示效果也会跟着改变
WS：（动态）世界空间， Canvas类似千一个游戏对象，可以手动改变其RectTransform组件的更改其大小与旋转。在渲染时， UI元素会根据它们在3D场景中的位置被渲染在其他游戏对象之前或之后，使其成为游戏视图中的一个成分。在做动态效果较多的界面时使用该模式比较方便。
？Graphic Raycaster组件：图形光线追踪，决定多个Canvas之间的事件响应顺序，Hierarchy中越靠上越后响应，当使用SSC和WS时，Block可以用来遮挡目标

## 1.2. EventSystem

输入事件管理系统（包括键盘、鼠标、或自定义输入），包含若干**事件监听**相关的组件，即可用来控制各类事件
Standalone Input Module响应标准输入和Touch Input Module响应触摸输入，都封装了Input模块的调用
EventSystem组件统一管理多个Input Module和各种Raycaster。该组件**每帧调用多个**Input Module处理用户的操作，同时还负责调用多个**Raycaster用于获取用户点击到的UGUJ控件或2D、3D物体**。

## 1.3. RectTransform组件

ps：当读者向一个Empty Object (空对象）添加一个UI Component组件时， Transform组件会自动变为RectTransform。
包括：PosX、PosY、PosZ Ul元素的位置，先定点，再定长和宽
Width、Height Ul元素的宽度和高度
Anchors 相对于父对象的锚点（锚框）Unity以锚框的左下角为坐标系的原点(0, 0)
Pivot UI元素的中心![Pivot图解](_v_images/20200213160039314_9083.png)
（UI 元素的旋转和缩放是围绕 Pivot 进行的）
Rotation 按轴旋转
Scale 按轴缩放
Shift:position+pivot
Alt:position+anchor
Shift+Alt:position+pivot+anchor
**Pos (X, Y, Z) ，矩形轴心点（pivot）与锚点（anchors）之间的距离。
Left, Top, Right, Bottom，矩形的四条边与锚框（anchors）之间的间距**
[UGUI - RectTransform](https://blog.csdn.net/weixin_38745092/article/details/80410767)

## 1.4. Panel控件 覆盖屏幕的平面（常用UI背景）

Image组件 改变材质：
法1：Source Image放需要显示的Sprite（精灵，背景文件）
Color中可以改变RGB的值以及灰度值（透明值）
法2：将准备好的材质文件（mat格式）拖拽到Material中

## 1.5. Button 控件

Image组件 管理按钮的显示图片，同Panel组件的Image组件
Button组件 管理单机按钮后的变化和监听
利用On Click()事件参数添加按钮点击监听：在监听列表中添加一个事件，然后在选框中选择挂有被监听事件脚本的对象，在Function中选择被监听的事件。那么每次这个按钮被按动的时候就会执行监听事件喽。

## 1.6. Text 控件

rich text是否为多格式文本 
Raycast Target（取消了以后在点击时光线就没了靶子鼠标就会穿透这个物体）是否标记为光线投射目标。勾选表示鼠标点击到该物体后不再穿透到下面的物体。
取消勾选则穿透该物体。tips：新建button时可设置其上物体为点击穿透

## 1.7. Image控件 显示一个非交互式的图片精灵

只支持Sprite类型的图片，因此需要把图片类型改为Sprite（2D and UI）
[Sprite 和Texture 的区别](https://blog.csdn.net/july_unity/article/details/79275097)
[Image与RawImage组件的区别](http://www.mamicode.com/info-detail-2154432.html)

## 1.8. Raw Image控件 显示一个非交互式的图像，可显示任何纹理

和Image的不同以及应用的不同：Raw Image不支持交互，支持UV Rect(用来设置只显示图片的某一部分)，可用于显示任何图片而不仅仅是Sprite，一般用在背景、图标上
UV Rect如何控制：（0.5，0.5，0.5，0.5）表示从贴图的中心往右往上显示图片的四分之一
如何在图片上呈现出相机拍摄的画面：新建RenderTexture，将其分别放到相机的TargetTexture和新建的RawImage的Texture。然后把相机作为rawimage的子对象就可以实现rawimage动，相机动，画面动了
[利用RawImage节点制作地图滚动效果](https://www.cnblogs.com/HangZhe/p/6869238.html)

## 1.9. Slider控件 圆点状滑块

Fill Area决定了开始的地方
实现滑到某个值的时候会发生不一样的变化？
Navigation是什么鬼?

## 1.10. Scrollbar控件 条状

与Slider的区别：Value决定初始位置，size决定大小，而Slider依靠Fill Area决定初始位置，value决定大小

## 1.11. Toggle控件 开关

？点击开关后更换一个开关的图片
？双击切换开关状态
？组开关
？Visualize的导航顺序在场景窗口中可视化
？点击后消失
实现不可修改的开关：添加开关组控件

## 1.12. Input Field控件

获取用户输入的密码
设置默认的提示信息
更换指定的提示文本框和文本框的风格类型：组件引用
CaretBlinkRate Placeholder
修改选中文本框时文本的颜色 Selection Color
？除了用作用户输入框还能干啥（主要是transition好像真没啥用武之地）
可以输入任何类型的字符standard，只能输入整数，只能输入带一个小数点的整数Decimal Number，只能输入字母和数字alphanumeric，自动大写首字母Name，自动隐藏且可以输入符号Password，自动隐藏且只能输入数字Pin，自定义输入类型Custom

## 1.13. Scrollbar制作滚动视图

如何制作滚动视图6步：新建Panel控件后修改锚点》给image组件构成的空物体布置网格管理》给Panel控件添加Mask组件（超出Panel控件范围的image将不会显示）》给Panel控件添加Scroll Rect组件，并将空物体拖到其Content选框中（实现拖动）》在滚动视图右边创建一个Scrollbar控件并将其选择为垂直拖动模式》将滚动条添加到滚动视图的Scroll Rect组件的Vertical Scrollbar上

# 2. 3种布局管理

如何更改布局管理：添加layout类型的组件
？布局的边缘填充（即偏移）Padding是什么
调整布局内的元素间距spacing
调整元素的自动对齐方式child alignment
调整元素的自动适应宽和高child force Expand
网格布局设置元素的主轴线Start Axis
？网格布局constraint的约束怎么使用
如何自动修改脚本中自动新建的UI预制件的布局管理方式：将脚本中实例化的UI设置为一个挂有网格布局的物体的子对象

```
using UnityEngine;
using System.Collections;
using UnityEngine.UI;
public class UGUILayout : MonoBehaviour {
    public GameObject UIMain;
    public GameObject items;
	// Use this for initialization
	void Start () {
        for (int i = 0; i < 10; i++)
        {
            GameObject item = (GameObject)Instantiate(items);
            item.transform.parent = UIMain.transform;
        }
	}
	// Update is called once per frame
	void Update () {
	}
}
```

# 3. 不规则形状的按钮的碰撞检测

如何添加多边形碰撞器组件：polygon collider 2D组件，在Physics2D组件组中
二维的UI，触摸屏控制的，是否在不规则的多边形区域内：本脚本**继承自UnityEngine.Ul.Image类**，并**重写了该类的lsRaycastLocationValid**，说明；方法。这个方法用于返回触摸点( screenPoint )是否在图片范围内。在该方法中使用Collider2D.OverlapPoint方法判断点是否在多边形区域内。

```
using UnityEngine;
using System.Collections;
using UnityEngine.UI;
public class UGUIImagePlus : Image {
    PolygonCollider2D PGcollider;
    new  void  Awake()
    {
        PGcollider = this.GetComponent<PolygonCollider2D>();
    }
    public override bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)
    {
        bool inside = PGcollider.OverlapPoint(screenPoint);
        Debug.Log(inside);
        return inside;
    }
}
```

如何实现不规则形状的按钮的碰撞检测：设置多边形碰撞组件》重写image类中lsRaycastLocationValid方法》去掉之前的image组件（否则继承了image类脚本无法挂载）》挂载碰撞检测脚本以后重新添加纹理》挂载监听事件

# 4. Touch和Input

## 4.1. Touch

手指的索引，手指的位置，距离上次改变的距离增量，自上次改变的时间增量，点击次数，触摸相位
？为什么要引入缩放阻尼
？怎么实现根据手指滑动发生旋转和两指放大收缩发生缩放的步骤：
摄像机距离球的位置为什么是负值：因为这个脚本是挂载到相机上的
Input.touchCount与Input.touches分别表示什么：Input.touches返回代表上一帧所有的触摸状态的对象列表（只读），每个记录都代表着一个手指在屏幕上的触碰状态。Input.touchCount表示每一帧触摸的数量，每帧之内不会改变（只读）。
Input.GetTouch：返回一个存放触摸信息的对象，Input.GetTouch(0)表示Input.touchCount的第一个触摸点的对象。
TouchPhase有哪几种类型：began，moved滑动的，stationary不动的; 静止的，ended离开的，canceled取消

```
	// 手指刚触摸到屏幕时必触发1次
        Input.GetTouch(0).phase == TouchPhase.Began;
        // 手指在屏幕滑动时触发多次
        Input.GetTouch(0).phase == TouchPhase.Moved;
        // 手指长按屏幕触发多次
        Input.GetTouch(0).phase == TouchPhase.Stationary;
        // 手指从屏幕移开时必触发一次
        Input.GetTouch(0).phase == TouchPhase.Ended;
        // 取消追踪如用户将超过5根手指或者脸贴在屏幕触发
        Input.GetTouch(0).phase == TouchPhase.Canceled;
```

ball.transform.Rotate(Vector3.up, -1*t.deltaPosition.x, Space.World);中旋转度数是负值的原因：判断绕y轴旋转时那个方向为正方向的方法是确定一个旋转轴后，左手握住拳头，拇指指向旋转轴的正方向，四指弯曲的方向为旋转的正方向。[原理与某个狗血的判断坐标系类型的方法](https://blog.csdn.net/yongyinmg/article/details/38727793)
？为什么用Input.GetAxis获取手指触屏的移动信息：因为手机屏幕的不同Touch. deltaPosition的返回值是不同的，所以使用起来比较不方便；而Input.GetAxis("Mouse X/Y")也可以实现，相应的效果，并且在iOS平台中也可以使用该方法。那设计Touch. deltaPosition还有啥意义
？下面的代码漏掉了一个手指移动一个手指不移动的情况，怎么处理
？为什么把调整相机位置的代码放到LateUpdate里
OnGUI中为什么把GUI.Button放到if语句里：监听事件，点击返回true

```
using UnityEngine;
using System.Collections;

public class TouchTest : MonoBehaviour {
    public GameObject ball;
    private float lastDis=0;
    private float cameraDis = -20;
    public float ScaleDump = 0.1f;//缩放阻尼
    void Update() {
        if (Input.touchCount ==1)//触控
        {
            Touch t = Input.GetTouch(0);//获取触控
            if (t.phase == TouchPhase.Moved)
            {
                //ball.transform.Rotate(Vector3.right, t.deltaPosition.y,Space.World);//竖直旋转 绕X轴
                C# => void Rotate(Vector3 axis, float angle, Space relativeTo = Space.Self);围绕自身或世界的axis轴旋转变换angle度
                //ball.transform.Rotate(Vector3.up, -1*t.deltaPosition.x, Space.World);//竖直旋转 绕Y轴
                ball.transform.Rotate(Vector3.right, Input.GetAxis("Mouse Y"), Space.World);//竖直旋转 绕X轴
                ball.transform.Rotate(Vector3.up, -1 * Input.GetAxis("Mouse X"), Space.World);//竖直旋转 绕Y轴
            }
        }
        else if (Input.touchCount > 1)
        {
            Touch t1 = Input.GetTouch(0);//获取触控
            Touch t2 = Input.GetTouch(1);//获取触控
            if (t2.phase == TouchPhase.Began)
            {
                lastDis = Vector2.Distance(t1.position, t2.position);//上一次两个手指的移动距离
            }
            if (t1.phase == TouchPhase.Moved && t2.phase == TouchPhase.Moved)
            {
                float dis = Vector2.Distance(t1.position, t2.position);
                if (Mathf.Abs(dis - lastDis)>1)//取绝对值
                    cameraDis += (dis - lastDis)*ScaleDump;
                cameraDis=Mathf.Clamp(cameraDis, -40, -5);
                lastDis = dis;//备份本次触摸结果
            }

        }
    }
    void LateUpdate()
    {
        this.transform.position = new Vector3(0,0,cameraDis);
    }
    void OnGUI()
    {
        string s = string.Format("Input.touchCount={0}\ncameraDIS=\n{1}",
            Input.touchCount,cameraDis);
        GUI.TextArea(new Rect(0, 0, Screen.width / 10, Screen.height), s);
        if (GUI.Button(new Rect(Screen.width * 9 / 10, 0, Screen.width / 10, Screen.height / 10),"quit"))
        {
            Debug.Log("quit");
            Application.Quit();
        }
    }
}

```

如何使用Input.GetAxis获取默认轴：想要读取轴向使用Input.GetAxis方法获取下列默认轴： “Horizontal” 和“Vertical” 映射于控制杆、A、W、S、D和箭头键（方向键）。 “Mouse X” 和“Mouse Y” 映射于鼠标,“Fire1”, “Fire2” “Fire3”映射于键盘的Ctrl、Alt、Cmd键和鼠标中键或控制器的按钮。每次输入在“Update()“之前不会再更新，所以建议你将所有的输入调用都写在Update方法中。（Update循环中） 
？如何设置新的输入设置：新的输入设置可以使用输入管理器来添加。如果你使用Input制作某种运动行为可以使用Input.GetAxis方法，它能够返回来自键盘、控制器或鼠标平缓并且可以设置的输入结果
移动设备怎样处理触摸数据：iOS和Android设备能够支持多点触控。你可以通过Input.touches属性集合访问在最近一帧中触摸在屏幕上的每一根手指的状态数据。
移动设备怎样处理移动数据和空间位置数据： 当设备移动时，它们的加速感应器硬件将报告它们在三维空间中沿着三个主轴的线性加速变化数据。你可以使用这些数据检测设备当前的移动方向（相对于地面）和突然间的方向改 变。硬件沿着某感应一轴加速就会立即返回重力值。如果值为1.0代表沿着给定轴的方向+1g的重力加速度，如果值为-1.0代表-1g的重力加速度。如果你保持设备垂直（主页键在下方）在你正前方，那么X轴就是指向你右侧的方向，Y轴指向正上方，Z轴就是你所面向的方向。你可以读取Input.acceleration属性获得设备的加速度信息。你也可以使用Input.deviceOrientation属性获取设备在三维空间中的方位偏移。检测方位变化在你想要制作游戏行为中会非常有用，当用户转动设备或拿着设备时它是不同的。速度感应装置在每一帧中能够轮询多次，想访问上一帧的所有速度样本你可以读取Input.accelerationEvents属性集合。这在重组玩家动作中会非常有用。例如将加速数据放入一个预测器中或者实现其他一些精确的动作捕捉。

## 4.2. Input变量

Input.mousePositon三维坐标的计算方式：以屏幕左下角为( 0 , 0 ) ,屏幕右上角坐标为( Screen. width, Screen.height )
anyKeyDown与anyKey的区别：连续按时前者仅第一帧返回True，而后者只要按下边始终返回True
inputString：返回输入的字符串的间隔是一帧
acceleration变量：返回的是表示三维空间中的线性加速度的三维向量，使用时需要先对获得变量进行规格化，然后转成速度，再把的速度放到transform.Translate里面
Input.touches

## 4.3. Input方法

Input.GetAxisRaw实现精灵的闪烁出现:只返回-1，0，1
监听虚拟按钮的GetButton方法、GetButtonDown方法与GetButtonUp方法区别，参数都是字符串型的键名
监听键盘按键的GetKey方法、GetKeyDown方法与GetKeyUp方法，参数既有字符串型的键名，也有KeyCode.UpArrow等预定义键码
监听鼠标操作的GetMouseButton方法、GetMouseButton Down方法和GetMouseButtonUp方法，参数有0，1，2，表示左右中

# 5. 三种销毁方法

如何实现10s后销毁某个物体
如何实现销毁网格内的所有物体
如何实现脚本被销毁时执行某个事件

# 6. 总结提问

怎么实现按钮监听?
一个按钮点击以后，按钮先变大后恢复，颜色变化，按钮上的字加粗，字体变化？
![](_v_images/20200215170704327_21430.png)
[哪些游戏有着非常漂亮的 UI 界面？](https://www.zhihu.com/question/29538229?sort=created&page=2)
![](_v_images/20200216101033901_14732.png)

```
using UnityEngine;
using System.Collections;

public class BallPrefabScript : MonoBehaviour {
    public int i = 5;                                       //声明整型变量i
    public int j = 0;                                       //声明整型变量j
    public Rigidbody BallPrefab;                            //声明刚体BallPrefab
    public float x = 0.0f;                                  //初始化x，y，z的坐标
    public float y = 4.0f;
    public float z = 0.0f;                                  
    public float k = 2.0f;                                  //声明实例化球的行数
    public int n = 4;
    int count = 0;                                          //声明一个计数器
    public Rigidbody[] BP;                                  //声明刚体数组
    void Start(){                                           //声明Start方法
        BP = new Rigidbody[10];                             //初始化刚体组数
        count = 0;                                          //计数器置0
        for (i = 0; i <= n; i++)                            //对变量i进行循环
            for (j = 0; j < i; j++)                         //对变量j进行循环
                //在自定义坐标位置实例化10球
                BP[count++] =(Rigidbody )Instantiate(BallPrefab,
                    new Vector3(x-2.0f*k*i+4.0f*j*k,2.0f,z-2.0f*1.75f*k*i),BallPrefab.rotation);
    }
}

```

# 7. GUI 8个变量

skin,color,tooltip,changed,backgroundColor,contentColor,enabled,depth

## 7.1. 敲击空格键切换预定的皮肤-skin变量

#引入GUI资源，设置皮肤索引=》设置皮肤变量，同时通过皮肤索引控制函数控制皮肤变量

#这个脚本是挂载到摄像机上的，但是guiskin资源到底是什么鬼呀！

C# => public static bool Button(Rect position, string text);
C# => public static bool Button(Rect position, Texture image);
C# => public static bool Button(Rect position, GUIContent content);
C# => public static bool Button(Rect position, string text, GUIStyle style);
C# => public static bool Button(Rect position, Texture image, GUIStyle style);
C# => public static bool Button(Rect position, GUIContent content, GUIStyle style);
//位置，text在按钮上显示的文本，image按钮的纹理图片，content用于按钮的文本图片和提示，样式

```
using UnityEngine;
using System.Collections;
public class Skin : MonoBehaviour {
    public GUISkin[] gskin;     //GUIskin资源引用
    public int skin_Index=0;    //皮肤索引
	void Update () {
        if (Input.GetKeyDown(KeyCode.Space))//实现资源集循环播放
        {
            skin_Index++;
            if (skin_Index >= gskin.Length)
            {
                skin_Index = 0;
            }
        }
	}
    void OnGUI()
    {
        GUI.skin = gskin[skin_Index];//设置皮肤变量
        if (GUI.Button(new Rect(0, 0, Screen.width / 10, Screen.height / 10),"a button"))//创建一个单次按下按钮。用户点击按钮事件立即触发。
        //C#用法 => public static bool Button(Rect position, string text);
        {
            Debug.Log("Button has been pressed");
        }
        GUI.Label(new Rect(0,Screen.height*2/10,Screen.width/10,Screen.height/10),"a lable");//在屏幕上创建一个文本或者纹理标签。标签没有用户交互，不捕捉鼠标点击，并总是被渲染为普通样式，如果你想创建响应用户输入的可视化控件，使用Box控件。 
    }
}
```

## 7.2. 改变图形用户界面组件的颜色

#直接应用GUI.color，包括了背景和文本颜色

```
using UnityEngine;
using System.Collections;
public class Test1 : MonoBehaviour {
	void OnGUI(){
		GUI.color = Color.yellow;
		GUI.Label (new Rect (Screen.width/10, Screen.height / 10, Screen.width / 5, Screen.height / 10), "Hellow World!");
		GUI.Box (new Rect(Screen.width/10, Screen.height / 5, Screen.width  / 5, Screen.height / 5),"A Box");
		GUI.Button (new Rect(Screen.width/10,Screen.height /2,Screen.width/5,Screen.height/10),"A Button");
}}

```

## 7.3. 设置图形用户界面的背景颜色

#直接应用GUI.backgroundColor

```
using UnityEngine;
using System.Collections;
public class Test2 : MonoBehaviour {
	void OnGUI(){
		GUI.backgroundColor = Color.yellow;
		GUI.Button (new Rect(Screen.width/10,Screen.height/10,
		                     Screen.width/5,Screen.height/10),"A Button");
	}
}

```

## 7.4. 设置图形用户界面组件中的文本颜色

#直接应用GUI.contentColor

```
using UnityEngine;
using System.Collections;                                           //导入系统类

public class Test3 : MonoBehaviour {
    void OnGUI() {                                                  //声明OnGUI方法
        GUI.contentColor = Color.yellow;                            //将文本颜色设置为黄色
        GUI.Button(new Rect(Screen.width/10,Screen.height/10,       //画一个按钮
            Screen.width/5,Screen.height/10),"A Button");
    }
}

```

## 7.5. 检测所有的GUI控件**输入数据**的值是否改变，是则true

#C# =>public static string TextField(Rect position, string text, int maxLength, GUIStyle style); 返回被编辑的字符串//GUI位置，用户编辑的文本，最大的长度，皮肤类型默认为GUISkin皮肤

```
using UnityEngine;
using System.Collections;                                       //导入系统类

public class Test4 : MonoBehaviour {
    public string stringToEdit="Modify me.";                    //声明一个字符串stringToEdit，内容为“Modify me.”
    void OnGUI() {                                              //声明OnGUI方法
            //绘制一个单行文本编辑框，并将输入的数据赋给变量stringToEdit
        stringToEdit = GUI.TextField(new Rect(Screen.width/10,
            Screen.height/10,Screen.width/4,Screen.height/10),stringToEdit,25);
        if (GUI.changed)                                        //调用changed变量，检测输入数据是否发生改变
            Debug.Log("Text field has changed.");               //若检测到输入数据发生改变，则打印提示信息
    }

}
```

## 7.6. 控制图形用户界面组件的启用情况,实现了全选功能锁

#Edit All Options变量和enabled挂钩，那么就能实现一键勾选了。为否时，button按键也不可用了。

GUI.enabled 设置为false禁用所用GUI互动，所有控件将被绘制半透明，并且将不响应用户输入。 
C# => public static bool Toggle(Rect position, bool value, string text);开关
C# => public static bool Toggle(Rect position, bool value, Texture image);
C# => public static bool Toggle(Rect position, bool value, GUIContent content);
C# => public static bool Toggle(Rect position, bool value, string text, GUIStyle style);
C# => public static bool Toggle(Rect position, bool value, Texture image, GUIStyle style);
C# => public static bool Toggle(Rect position, bool value, GUIContent content, GUIStyle style); 
//返回bool类型，按钮的新值//位置，状态，text显示的文本iamge显示的图片，content用于按钮的文本，图片和提示信息？，style样式

```
using UnityEngine;
using System.Collections;                       //导入系统类

public class Test5 : MonoBehaviour {
	public bool allOptions = true;              //声明一个初始值为true的布尔型变量allOptions
    public bool extended1 = true;               //声明一个初始值为true的布尔型变量extended1
    public bool extended2 = true;               //声明一个初始值为true的布尔型变量extended2
    void OnGUI(){                               //声明OnGUI方法
            //在自定义区域内绘制一个名为Edit All Options的开关，其初始状态为allOptions
        allOptions = GUI.Toggle(new Rect(0,0,Screen.width/5,
            Screen.height/10),allOptions,"Edit All Options");
        GUI.enabled = allOptions;               //将allOptions的值赋给enabled组件
            //分别在各个自定义的区域内绘制两个开关
        extended1 = GUI.Toggle(new Rect(Screen.width/10,Screen.height/10,
            Screen.width/5,Screen.height/10),extended1,"Extended Option1");
        extended2 = GUI.Toggle(new Rect(Screen.width / 10, Screen.height / 5,
           Screen.width / 5, Screen.height / 10), extended2, "Extended Option2");
        GUI.enabled = true;                     //将enabled组件的值设置为true
            //在自定义的区域绘制一个名为ok的按钮，并判断是否被按下
        if (GUI.Button(new Rect(0, Screen.height * 3 / 10, Screen.width / 3, Screen.height / 10), "ok"))
            print("user clicked ok");//
	}}
```

## 7.7. 鼠标点击或移动到按钮时显示提示信息（没弄明白）

C# =>public GUIContent(string text); 构建一个仅包含文本的GUIContent对象。这个没用直接用字符串就行
C# =>public GUIContent(Texture image); 构建一个仅包含一个图片的GUIContent对象
C# =>public GUIContent(string text, Texture image); 构建一个包含文本和一个图片的GUIContent对象。
**C# =>public GUIContent(string text, string tooltip); 构建一个包含文本的GUIContent对象；当用户鼠标经过它的时候，全局GUI.tooltip设置为tooltip。 **
C# => public static void Label(Rect position, string text);
C# => public static void Label(Rect position, Texture image);
C# => public static void Label(Rect position, GUIContent content);
C# => public static void Label(Rect position, string text, GUIStyle style);
C# => public static void Label(Rect position, Texture image, GUIStyle style);
C# => public static void Label(Rect position, GUIContent content, GUIStyle style);
在屏幕上创建一个文本或者纹理标签。标签没有用户交互，不捕捉鼠标点击，并总是被渲染为普通样式，如果你想创建响应用户输入的可视化控件，使用Box控件。 标签也可以用来显示纹理，而不仅仅用来显示字符串。
C# => public static string tooltip; 控制鼠标当前通过对象的提示信息。当你创建GUI控件的时候，你可以传递一个提示信息给他们。*这可以通过改变内容参数去自定义GUIContent物体，而不是仅仅传递一个字符串。* 当鼠标通过控件有提示信息的控件时，它设置全局GUI.tooltip的值到你传递的提示信息。如果鼠标没有通过任何控件，这个值设置到有键盘焦点的控件。在OnGUI代码的最后你可以创建一个标签来显示GUI.tooltip的值。

```
using UnityEngine;
using System.Collections;

public class Test6 : MonoBehaviour {
    	void OnGUI() {
            GUI.Button(new Rect(Screen.width / 10, Screen.height / 10, Screen.width / 5, Screen.height / 10), new GUIContent("Click me", "This is the tooltip"));这个按钮的名称为Click me，提示信息为This is the tooltip
            GUI.Label(new Rect(Screen.width / 10, Screen.height / 5, Screen.width / 5, Screen.height / 10), GUI.tooltip);
        }
}
```

### 7.7.1. 不同按钮显示不同的tooltip提示信息

难道说gui.tooltip就是一个专门用来创建提示标签的变量？

```
using UnityEngine;
using System.Collections;                           //导入系统类

public class Test7 : MonoBehaviour {
    void OnGUI(){                                   //声明OnGUI方法
            //在自定义区域绘制一个Box，Box中的内容为Box，且提示信息为this box has a tooltip
        GUI.Box(new Rect(Screen.width / 20, Screen.height / 10, Screen.width * 3 / 5,
            Screen.height * 3 / 5), new GUIContent("Box", "this box has a tooltip"));
            //在自定义区域绘制一个名为No tooltip here的按钮
        GUI.Button(new Rect(Screen.width/10, Screen.height / 3, Screen.width / 2,
            Screen.height / 10 ), "No tooltip here");
            //在自定义区域绘制一个内容为I have a tooltip的按钮，且提示信息为The button overrides the box
        GUI.Button(new Rect(Screen.width / 10, Screen.height  / 2, Screen.width / 2, 
            Screen.height / 10), new GUIContent("I have a tooltip", "The button overrides the box"));
            //在自定义区域绘制一个标签，标签显示的内容为GUI.tooltip提供的信息
        GUI.Label(new Rect(Screen.width / 10, Screen.height  / 5, Screen.width  * 2 / 5,
            Screen.height / 10), GUI.tooltip);
    }

}

```

### 7.7.2. 鼠标悬停与离开事件？这个脚本里面潜在的逻辑没验证

GUILayout界面布局类是Unity界面自动布局的接口。 
Event对于每个事件在脚本OnGUI中被调用；OnGUI潜在每帧被多次调用。Event.current对应于在OnGUI里调用当前事件

```
using UnityEngine;
using System.Collections;                                           //导入系统类

public class Test8 : MonoBehaviour {
    public string lastTooltip = " ";                                //声明一个名为lastTooltip的空字符串
    void OnGUI(){                                                   //声明OnGUI方法
        GUILayout.Button(new GUIContent("Play Game", "Button1"));   //通过GUI的布局管理器绘制一个按钮Button1                                                                    
        GUILayout.Button(new GUIContent("Quit", "Button2"));        //通过GUI的布局管理器绘制一个按钮Button2
        if (Event.current.type == EventType.Repaint && GUI.tooltip != lastTooltip){
                                                                    //对当前事件进行判定
            if (lastTooltip != "")                                  //若lastTooltip不为空，则发送消息
                SendMessage(lastTooltip + "OnMouseOut", SendMessageOptions.DontRequireReceiver);
            if (GUI.tooltip != "")                                  //若lastTooltip为空，则发送消息
                SendMessage(GUI.tooltip + "OnMouseOver", SendMessageOptions.DontRequireReceiver);
            lastTooltip = GUI.tooltip;                              //将lastTooltip的值置为GUI.tooltip
        }
    }
    void Button1OnMouseOver(){                                      //声明Button1MouseOver方法
        Debug.Log("Play game got focus");                           //打印提示信息
    }
    void Button2OnMouseOut(){                                       //声明Button2MouseOver方法
        Debug.Log("Quit lost focus");                               //打印提示信息
    }
}

```

## 7.8. 对当前执行的图形用户界面控件进行排序

两个按钮来回切换显示，当有不同的脚本同时运行时通过变量depth对当前执行的GUI行为进行排序
C# => public static bool RepeatButton(Rect position, string text);
C# => public static bool RepeatButton(Rect position, Texture image);
C# => public static bool RepeatButton(Rect position, GUIContent content);
C# => public static bool RepeatButton(Rect position, string text, GUIStyle style);
C# => public static bool RepeatButton(Rect position, Texture image, GUIStyle style);
C# => public static bool RepeatButton(Rect position, GUIContent content, GUIStyle style);
当用户点击按钮的时候返回true。 创建一个按钮，只要用户按着不放，将一直被激活。从按下按钮到释放按钮的时间内重复引发其 Click 事件的控件，也就是说它将连续不停的发送点击事件。

```
using UnityEngine;
using System.Collections;                                                       //导入系统类

public class Test9 : MonoBehaviour {                                            //声明一个类Test9，并继承类MonoBehaviour
    public static int guiDepth = 0;                                             //声明一个初始值为0的静态整型变量guiDepth
    void OnGUI(){                                                               //声明OnGUI方法
        GUI.depth = guiDepth;                                                   //将GUI.depth设置为guiDepth
        if (GUI.RepeatButton(new Rect(Screen.width / 10, Screen.height / 10,    //绘制一个名为GoBack的RepeatButton
            Screen.width / 5, Screen.height / 5), "GoBack")){                   //若持续按下按钮GoBack，guiDepth变量置为1
            guiDepth = 1;
            Test10.guiDepth = 0;                                                //将Test10.guiDepth的值置为0
        }
    }
}

using UnityEngine;
using System.Collections;                                           //导入系统类

public class Test10 : MonoBehaviour {                               //声明一个类Test10，并继承类MonoBehaviour
    public static int guiDepth = 1;                                 //声明一个初始值为1的静态整型变量guiDepth
    void OnGUI(){                                                   //声明OnGUI方法
        GUI.depth = guiDepth;                                       //将GUI.depth设置为guiDepth
        if (GUI.RepeatButton(new Rect(Screen.width / 5, Screen.height / 5, Screen.width / 5, Screen.height / 5), "GoBack")){
                                                                    //绘制一个名为GoBack的RepeatButton
            guiDepth = 1;                                           //若持续按下按钮GoBack，guiDepth变量置为1
            Test9.guiDepth = 0;                                     //Test9.guiDepth的值置为0
        }
    }

}

```

# 8. GUI 30个控件（15/30）

GUI是一个很大的类，这里面写好了很多的函数，使用时就是对这些函数重写（重新构造），值得关注的是每一个方法里面都定义了一些更加细节的变量，这些变量可以用过构造进行修改，也可以通过连续的点运算符进行调用

## 8.1. GUI.Label();绘制文本或者纹理标签

文本或者纹理标签控件：C# => public static void Label(Rect position, string text);
C# => public static void Label(Rect position, Texture image);
C# => public static void Label(Rect position, GUIContent content);
C# => public static void Label(Rect position, string text, GUIStyle style);
C# => public static void Label(Rect position, Texture image, GUIStyle style);
C# => public static void Label(Rect position, GUIContent content, GUIStyle style);
区分一下string(仅文本)和GUIContent(文本，图片和信息提示)，才发现这两个没有一块存在于一个构造函数中的情况。GUIStyle界面样式是一个挺大的类，包括激活对齐高度绘制字体图片行高名字悬停拉伸宽度自动换行

## 8.2. GUI.DrawTexture();绘制图片（纹理图）

纹理图片控件:C# => public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend, float imageAspect);bool alphaBlend图片的混合模式，是否通道混合图片显示，默认为混合通道，如果不，图片直接被绘制显示。imageAspect源图片的长宽比，如果为0，则使用图像的长宽比。通过“宽/高”获得所需的长宽比，这允许源图像的宽高比被调整而不影响像素宽度和高度。

## 8.3. DrawTextureWithTexCoords在给定坐标系内绘纹理图

纹理图片控件C# => public static void DrawTextureWithTexCoords(Rect position, Texture image, Rect texCoords, bool alphaBlend);texCoords当在内部绘制时，绘制的纵横比不适合时，如何缩放图形。alphaBlend是否透明度混合到显示上(默认是)。如果为false，该图片绘制于显示器上。

## 8.4. GUI.Box();绘制一个图形化盒子，响应用户输入？

图形盒子控件

## 8.5. Button：bool型，绘制单次按下按钮

按钮控件。下面这个脚本的if (!btnTexture) 我发现类的对象本身表示bool型的是否被实例化

```
using UnityEngine;
using System.Collections;

public class GUIButton : MonoBehaviour{
    public Texture btnTexture;                                                  //声明一个2D纹理图片    
    void OnGUI(){                                                               //声明OnGUI方法
        if (!btnTexture){                                                       //判断是否存在纹理图片
            Debug.LogError("Please assign a texture on the inspector");         //若不存在，打印提示消息
            return;
        }
        if (GUI.Button(new Rect(Screen.width / 10, Screen.height / 10, Screen.width / 10, Screen.width / 10), btnTexture))
                                                                                //创建一个纹理按钮，并进行是否执行按钮操作的判定
            Debug.Log("Clicked the button with an image");                      //若单击按钮，则打印提示信息
        if (GUI.Button(new Rect(Screen.width / 10,Screen.height / 3, Screen.width / 5,Screen.height / 10), "Click"))
                                                                                //创建一个文本按钮，并进行是否执行按钮操作的判定
            Debug.Log("Clicked the button with text");                          //若单击按钮，则打印提示信息

    }
}
```

## 8.6. RepeatButton bool型，持续按下时激活，并持续发送OnClick事件

按钮控件

## 8.7. Textfield 下面编辑框都是String型，绘制一个单行文本编辑框

单行文本编辑控件：C# => public static string TextField(Rect position, string text);
C# =>public static string TextField(Rect position, string text, int maxLength);
C# =>public static string TextField(Rect position, string text, GUIStyle style);
C# =>public static string TextField(Rect position, string text, int maxLength, GUIStyle style);
maxLength 表示控制字符的最大长度

## 8.8. PasswordField 绘制一个可编辑的密码输入框（并可实时屏蔽密码）

密码输入框控件C# => public static string PasswordField(Rect position, string password, char maskChar);
C# => public static string PasswordField(Rect position, string password, char maskChar, int maxLength);
C# => public static string PasswordField(Rect position, string password, char maskChar, GUIStyle style);
C# => public static string PasswordField(Rect position, string password, char maskChar, int maxLength, GUIStyle style); char maskChar表示密码的字符遮罩

```绘制一个最大长度为25并能用*号来屏蔽密码的密码输入框
using UnityEngine;
using System.Collections;

public class GUIPwField : MonoBehaviour {
    public string passwordToEdit = "My Password";                   //声明一个字符串
    void OnGUI()                                                    //声明OnGUI方法
    {
            //绘制一个密码编辑框，并设置用*号来屏蔽密码，且设置密码编辑框的最大长度为25
        passwordToEdit = GUI.PasswordField(new Rect(Screen.width / 10,Screen.height / 10,
            Screen.width / 2, Screen.height / 10), passwordToEdit, "*"[0], 25);
    }    
}
```

## 8.9. TextArea 绘制一个多行文本编辑框

多行文本编辑控件

## 8.10. SetNextControlName void型，给下一步控制设置事件名字？？

设置下一个控件名字

## 8.11. GetNameOfFousedControl String型，得到当前控制焦点的名字

获取有焦点被命名控件的名字

## 8.12. FocusControl void型，在当前焦点处通过键盘输入值用来显示？？

焦点控件

## 8.13. Toggle bool型，通过控制开关的闭合来执行一些具体的操作

开关控件

``` 实现默认为关的一个文本开关和一个纹理图片开关
using UnityEngine;
using System.Collections;

public class GUIToggle : MonoBehaviour {
    public Texture aTexture;                                                        //声明一个纹理图片
    private bool toggleTxt = false;                                                 //声明一个初始值为false的bool变量toggleTxt
    private bool toggleImg = false;                                                 //声明一个初始值为false的bool变量toggleImg
    void OnGUI(){                                                                   //声明OnGUI方法
        if (!aTexture){                                                             //判定是否存在纹理图片
            Debug.LogError("Please assign a texture in the inspector.");            //若没有则打印提示信息
            return;
        }
        //绘制一个名为A Toggle text且初始状态为toggleTxt的开关
        toggleTxt = GUI.Toggle(new Rect(Screen.width/ 10,Screen.height/ 10,Screen.width/ 3,Screen.height / 10), toggleTxt, "A Toggle text");
        //绘制一个纹理图片为aTexture且初始状态为toggleImg的开关
        toggleImg = GUI.Toggle(new Rect(Screen.width/ 10,Screen.height/ 4,Screen.width / 10,Screen.height / 10), toggleImg, aTexture);
    }
}
```

## 8.14. Toolbar int型，绘制工具条及上面的工具按钮，返回被选中按钮的索引号

工具栏控件：C# => public static int Toolbar(Rect position, int selected, string[] texts);
C# => public static int Toolbar(Rect position, int selected, Texture[] images);
C# => public static int Toolbar(Rect position, int selected, GUIContent[] content);
C# => public static int Toolbar(Rect position, int selected, string[] texts, GUIStyle style); 
C# => public static int Toolbar(Rect position, int selected, Texture[] images, GUIStyle style);
C# => public static int Toolbar(Rect position, int selected, GUIContent[] contents, GUIStyle style); 
selected被选择按钮的索引号。texts，images，contents，style都是刻画按钮的，只有position是工具条

```绘制一个内容为toolbarStrings且当前焦点在第toolbarInt上的工具条
using UnityEngine;
using System.Collections;

public class GUIToolbar : MonoBehaviour {
    public int toolbarInt = 0;                                        //声明一个初始值为0的整型变量toolbarInt
    public string[] toolbarStrings = new string[] { "Toolbar1", "Toolbar2", "Toolbar3" };
                                                                      //声明一个具有内容的字符型数组
    void OnGUI(){                                                     //声明OnGUI方法
        //绘制一个内容为toolbarStrings且当前焦点在第toolbarInt上的工具条
        toolbarInt = GUI.Toolbar(new Rect(Screen.width /10,Screen.height /10, Screen.width /2, 
            Screen.height /10), toolbarInt, toolbarStrings);
    }
}

```

## 8.15. SelectionGrid int型，绘制一个网格按钮，并可在自定义的网格内置入具体的功能按钮，返回被选择按钮的索引号

网格按钮控件
C# => public static int SelectionGrid(Rect position, int selected, string[] texts, int xCount);
C# =>public static int SelectionGrid(Rect position, int selected, Texture[] images, int xCount);
C# =>public static int SelectionGrid(Rect position, int selected, GUIContent[] content, int xCount);
C# =>public static int SelectionGrid(Rect position, int selected, string[] texts, int xCount, GUIStyle style);
C# =>public static int SelectionGrid(Rect position, int selected, Texture[] images, int xCount, GUIStyle style);
C# =>public static int SelectionGrid(Rect position, int selected, GUIContent[] contents, int xCount, GUIStyle style); xCount在水平方向上有多少元素，控件将缩放去适合宽度，除非样式定义了固定宽度(fixedWidth)。

```绘制一个每行有2个内容为selStrings且当前焦点在第selGridInt上的网格按钮控件
using UnityEngine;
using System.Collections;

public class GUISeGrid : MonoBehaviour {

    public int selGridInt = 0;                                      //声明一个初始值为0的整型变量selGridInt
    public string[] selStrings = new string[] { "Grid 1", "Grid 2", "Grid 3", "Grid 4" };
                                                                    //声明一个具有内容的字符型数组
    void OnGUI()                                                    //声明OnGUI方法
    {
        //绘制一个内容为selStrings且当前焦点在第selGridInt上的网格按钮控件
        selGridInt = GUI.SelectionGrid(new Rect(Screen.width /10,Screen.height /10,
            Screen.width /2, Screen.height /3), selGridInt, selStrings, 2);
    }

}

```

## 8.16. HorizontalSlider

水平的滑杆控件，并且可以自己设置阙值

## 8.17. Vertica!Slider

垂直滑杆控件，并且可以自己设置阑值

## 8.18. Ho如ntalScrollbar

水平的滚动条控件，并且可以自己设置阙值

## 8.19. Vertica!Scrollbar

垂直滚动条控件，并且可以自己设置阅值

## 8.20. ScrollTo

将内容滚动到制定位置

## 8.21. BeginScrollView

滚动视图控件

## 8.22. EndScrol!View

结束滚动视图

## 8.23. Window

窗口控件

## 8.24. Bring WindowToFront

使窗口到前面

## 8.25. Drag Window

可拖动的窗口控件

## 8.26. Bring WondowToBack

使窗口到后面

## 8.27. Focus Window

焦点窗口控件

## 8.28. Unfocus Window

失焦窗口

## 8.29. BeginGroup

开始组控件，必须与EndGroup配对出现

## 8.30. EndGroup

结束组控件，必须与BeginGroup配对出现

## 物理引擎--王寿岩
第一二三章的总结
第一章Unity的基础以及开发环境的搭建
1.Unity 是由 Unity Technologies 开发的一个能够轻松创建三维视频游戏、 建筑可视化及实时三维动画等互动内容的、多平台的综合型开发工具，也是一个全面整合的专业游戏引擎。
2.Unity类似千Director、BlenderGame Engine、Vmools或TorqueGame Builder等利用交互的图形化开发环境为首要方式的软件。由Unity开发的基千Android平台 、iPhone平台的游戏和大型的 3D网页游戏很受欢迎。
3.第一个Unity程序，先启动Unity在单击New project，选择3D选项，在单击Creat project按钮。
第二章Unity集成开发环境详解
1.Unity集成开发环境的默认布局分割为一系列不同的面板和带有标签的窗口。
2.如果布局被不小心弄乱了，可以通过执行“Window-Layouts”命令找到自己保存的布局。
3.菜单栏和工具栏详情看第28和29页。
4.摄像机导航:可以把场景控制面板想象成一个虚拟的摄像机输出或焦点
5.Aspect 下拉列表可以实时改变游戏阅览画板的显示比例，即使游戏正在运行。
6.状态栏和控制器是Unity集成开发环境中两个很有用的调试工具。
7.动画视图使读者可以在这里查看或是调整动画曲线。
8.动画控制器编辑视图用千编辑动画控制器。
9.Unity 是一款功能强大的集成开发编辑器和引擎， 为开发者提供了创新和发布一款游戏所必需的工具， 无论开发者是要开发一款 3D第一人称射击游戏还是休闲的 2D 智力游戏。 
10.Unity 的许可方式及可选的插件使得读者在需要时可以得到适量的和定制的功能。
第三章Unity脚本程序开发
1.Start 方法：这个方法在游戏场景加载时被调用，在该方法内可以写一些游戏场景初始化之类的代码。
2.Update 方法：这个方法会在每一帧渲染之前被调用，大部分游戏代码在这里执行，除了物理部分的代码。
3.FixedUpdate方法：这个方法会在固定的物理时间步调调用一次。这里也是基本物理行为代码执行的地方。
4.Unity 中很多对游戏对象的操作都是通过在脚本中修改对象的 Transform (变换属性）与Rigidbody C刚体属性）参数来实现的。
5. 一般情况下，在Unity中，x轴为红色的轴表示左右，y轴为绿色的轴表示上下， :z轴为蓝色的轴表示前后。
6.在Unity中记录时间需要用到Time类。Time类中比较重要的变量为deltaTime(只读）， 它指的是从最近一次调用 Update或者FixedUpdate方法到现在的时间。
7.在Unity中，附加到游戏对象上的组件可以通过GetComponent方法获得。
8.Unity脚本中可以使用FindWith Tag方法和Find方法来获取游戏对象，FindWithTag方法获取指定标签的游戏对象，Find方法获取指定名字的游戏对象。
9.一些事件回调方法的参数中包含了特殊的游戏对象或组件信息，例如触发碰撞事件的Collider组件。在OnTiggerStay方法的参数中有一个碰撞体参数， 通过这个参数能得到碰撞的刚体。
10.Unity 脚本中可以通过 FindObjectsOIType 方法和 FindObjectOffype 方法来找到挂载特定类型组件的游戏对象。
11.Unity 中如果想创建很多相同的物体（如射击出去的子弹、保龄球瓶等）时 ，可以通过实例 化(Instantiate)快速实现，而且实例化 出来的游戏对象包含了这个 对象 所有的属性，就能保证原封不动地创建所需的对象。 实例化在Unity中有 很多用途， 充分地使用它非常必要。
12.MonoBehaviour类是每个脚本的基类， 其继承自Behaviour类。
13.Transform类实例化的对象，用于储存并操控物体的位置、旋转和缩放。
14.Rigidbody类实例化的对象。它可以让物体接受力和扭矩，让物体相对真实地移动。
15.角色控制器是CharacterController类的实例化对象， 用千第三人称或第一人称游戏角色控制。
第四章UGUI图形用户界面系统
1.创建：菜单栏点击“GameObject->UI”创建UI。
2.创建第一个UGUI控件时，若场景中没有巳经存在的Canvas(画布）游戏对象， 系统就会自动创建一个，并将UGUI控件设置为Canvas的子对象，同时会自动创建一个名为"EventSystem"的游戏对象，上面挂载了若千事件监听相关的组件可供设置。
3.Canvas画布：在绘画顺序上和Hierarch面板中的排序是一致的。
4.UGUI中每个控件包括Canvas都会带一个RectTransform组件，用于显示画布的位置和Transform功能一样。
5.Planel控件 覆盖画布整个平面。
6.Botton控件 设置一个按钮其中的image组件控制图案，text控制字样。
7.监听挂载：例Botton组件中点击“On Click（）”事件中添加按钮的点击监听：代码如下
using UnityEngine;
using System.Collections;
public class UGUIOnClick : MonoBehaviour {
public void Onbt1Click(int index)  {     //监听方法
Debug.Log("This is bt"+index);     //打印
}
}
单机Button组件下面的“On Click（）”点击+添加一个事件，把创建的代码添加到事件中
8.Test控件：显示文字
9.Image控件：显示图片
10.Silder控件：创建一个滑块，可以设定最大值和最小值，例：音量的调节
11.Scrollibar控件：和silder控件相似
12.Toggle控件：显示开关（类似对勾）
13.预制件：创建“Asserts--Creat--prefab”（制作一个物体把他的性质复制到预制件中 ）
第五章物理引擎
1.力矩是来描述力对物体的转动作用，是描述作用的物理量，就是说转的厉不厉害。
2.碰撞检测模式(Collision Detection)：Unity 3D 提供了三种不同的碰撞检测模式，用于应对不同情况下的碰撞检测。--
本属性默认使用占用资源较少的离散模式(Discrete)： 对千静止或运动速度较慢的物体建议使用该模式，
连续模式(Continuous);建议对千高速运动或体积较小的物体使用。
动态连续模式(Continuous Dynamic)：被使用了连续检测模式的物体所撞击的物体。
3.刚体特性：质量（Mass），阻力(Drag)，旋转阻力(AngularDrag)，使用重力（UseGravity），是否遵循运动学(Is Kinematic)。
4.刚体变量：角速度(angular Velocity)，位移速度(velocity)，重心(centerOfMass)，碰撞检测开关(detectCollisions)，惯性张量(inertiaTensor），惯性张量旋转(inertiaTensorRotation)，最大角速度(maxAngularYelocity)，最大穿透速度(maxDepenetrationVeloctiy)，坐标 (position)，旋转 (rotation)，是否使用锥形摩擦 (useConeFriction)。
5.刚体常用方法：给刚体施加力(AddForce)，旋转刚体 (MoveRotation)，添加爆炸力 (AddExplosionForce)注意！【如果将爆炸力的值设置为负数，则该方法可以模拟出引力的效果，使在半径之内的物体因爆炸的作用向中心点靠拢。（黑洞）。】，在指定点施加力 (AddForceAtPosition )，施加相对力矩(AddRelativeTorque)，强制休眠 (Sleep)，唤醒 (WakeUp)。
6.物理管理器浏览：
点击菜单栏的Edit，选择"ProjectSettings"选项，选择Physics。
7.物理管理器参数：重力(Gravity)。默认材质(DefaultMaterial)，反弹阙值(Bounce Threshold)，休眠阙值（Sleep Threshold）。
8.粒子系统包括1.粒子系统主体2.喷射3.形态4.生命周期内的速度偏移5.生命周期的限制速度6.生命周期内的受力偏移7.生命周期的颜色8.颜色随速度变化9.生命周期内的大小11.生命周期内的转速14.碰撞16.纹理层动画17.渲染器。
9.制作虚拟遥感方法
![](_v_images/20200418201131478_1988845167.png)

虚拟遥感代码：
using UnityEngine;
using System.Collections;
public class Car : MonoBehaviour {
public WheelCollider FLCollider; 
public WheelCollider FRCollider;
public EasyJoystick myJoystick;
public float maxTorque = 500; 
public float maxAngle = 20;
// Use this for initialization
void Start () {
 GetComponent<Rigidbody>().centerOfMass = new Vector3(0, -0.8f, 0); }
`void FixedUpdate () {
 FLCollider.motorTorque = maxTorque * myJoystick.JoystickTouch.y;  FLCollider.steerAngle = maxAngle * myJoystick.JoystickTouch.x;  FRCollider.motorTorque = maxTorque * myJoystick.JoystickTouch.y;  FRCollider.steerAngle = maxAngle * myJoystick.JoystickTouch.x; 
}
}
控制车轮移动转动代码
using UnityEngine;
using System.Collections;
public class Wheel : MonoBehaviour {
public WheelCollider CPCollider; 
public float CirValue=0;
// Use this for initialization void Start () {
}
void Update () {
transform.rotation = CPCollider.transform.rotation*Quaternion.Euler(CirV alue,CPCollider.steerAngle,0);
CirValue += CPCollider.rpm * 360 / 60 * Time.deltaTime; 
}
}

[toc]

![](../图床/20200217223032881_14269.png)

# 1. 刚体 Rigibody

能受作用力和扭矩进行运动的

## 1.1. 什么时候使用is Kinematic

为true时不遵循牛顿运动学，仅受脚本和动画影响，死亡的敌人身体不再和人物发生碰撞？

## 1.2. 当你发现刚体运动时抖动可以怎么处理，原因？

对游戏主对象进行Rigidbody.interpolation 插值处理
插值允许你以固定的帧率平滑物理运行效果。插值默认是关闭的。通常刚体插值用于玩家角色。物理是不连续（discrete）的时间步运行，而显卡以可变的帧率渲染。这可能导致物体抖动，因为物理和显卡不完全同步。这个效果是细微的但是通常会在玩家角色上看到，尤其是如果相机跟随主角色。建议为主角打开插值，但其他的禁用。

## 1.3. 穿模的原因以及三种碰撞检测模式的适应情况

碰撞检测模式(Collision Detection )。假设一个高速运动的物体，其两个相邻物理模拟时间点所进行的位移大于被碰撞物体的厚度，且本身厚度足够小，则该物体将有可能直接穿过被碰撞物体，这种现象称为碰撞检测的穿透。为防止这种现象的出现， Unity 3D提供了三种不同的碰撞检测模式，用于应对不同情况下的碰撞检测。本属性默认使用占用资源较少的离散模式 (Discrete),对千静止或运动速度较慢的物体建议使用该模式，而对千高速运动或体积较小的物体建议使用连续模式(Continuous);被使用了连续检测模式的物体所撞击的物体，则应该使用动态连续模式(Continuous Dynamic)。

## 1.4. 如何达到物体的位移和旋转不受物理定律的约束的效果

约束条件( Constraints)。该属性表示的是该物体的位移或旋转是否受到物理定律的约束。默认状态下，物体的任意方向的位移和任意轴的旋转都是受物理定律的约束的，开发人员通过设置指定方向的位移和指定轴的旋转，可以灵活地设置物体的状态，达到自己想要的效果。

## 1.5. 怎么实现静止物体的旋转

设置角速度

## 1.6. 怎么给物体施加一个力

GetComponent<Rigibody>().AddForce(Vector3.up,ForceMode.Force);
force是默认方式，使用刚体的质量计算，持续力，以每帧间隔时间为单位计算动量。(持久还是爆发，质量是否忽略)

## 1.7. 爆炸力与引力怎么实现

AddExplosionForce

## 1.8. 刚体休眠和唤醒的意义

节约资源，提高程序的运行效率

# 2. 碰撞器++

## 2.1. 实现射线扫描检测的语法

 => public bool SweepTest(Vector3 direction, out RaycastHit hitInfo, float maxDistance = Mathf.Infinity, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteractio
C#n.UseGlobal); 扫描该刚体的方向，hitInfo包含更多碰到的信息，扫描的长度，指定是否查询碰到触发器。
将沿着direction的方向产生一条长度为" maxDistance "的射线"hitlnfo ", 若该射线碰撞到其他刚体，则返回true,否则返回false。第一个被检测到的刚体信息储存在" hjtlnfo "上。
SweepTestAll 会返回RaycastHit类型的数组，其中储存了“如ection "方向所有检测到的刚体的信息。该数组的最大长度不超过128。
ps：关于网格碰撞器：1.标记为凸起的（Convex ）的网格碰撞器才能够和其他网格碰撞器发生碰撞。
2.如果碰撞双方是两个网格碰撞器（Mesh Collider）默认不会发生碰撞的，一方需要添加刚体(Rigidbody)并且勾选Convex。慎用，精度超高，但效率很低。
![](../图床/20200217174104835_11148.png)

## 2.2. 关于3D射线拾取：https://blog.csdn.net/jxw167/article/details/54562174

8.2

## 2.3. 怎么打开物理管理器

edit-project settings-Physics 

## 2.4. Mesh Collider的特点，盒子/球体/胶囊碰撞器的适用情况

地形，车轮碰撞器
一般只适用球方胶囊三种简单碰撞器，而不使用网格碰撞器

## 2.5. 怎么实现球C和AB的不碰撞检测

Physics.IgnoreCollision(ballA.GetComponent<Collider>() , ballC . GetComponent<Collider>(
));
Physics.IgnoreCollision(ballB. GetComponent<Collider>(), ballC . GetComponent<Collider>()) ;

## 2.6. 实现层层碰撞过滤（类A和类B的物体不碰撞）的步骤

在属性查看器的Layer中添加层》给各个物体赋予层》在物理管理器中勾掉对应图层的碰撞按钮

## 2.7. 如何通过修改物体的摩擦因子/弹性因子/各向异性实现特殊的碰撞效果

在project中创建物理材质修改这些变量，将其作为该物体的物体碰撞器的一个外部引用赋过去，

# 3. 粒子系统

## 3.1. 两种创建粒子系统的方法

作为场景中单独的物体，作为组件

## 3.2. 粒子系统主要参数的含义duration,looping,prewarm,start delay,start lifetime(和duration区分),start speed,start size,start rotation,start color,GravityModifier(有则坠下),Inherit Velocity（粒子出生时的速率占总速率的百分比）,simulation space,play on awake,max particles

P230

## 3.3. 怎么调节粒子系统粒子的喷射状态

emision列表中的rateovertime和bursts
一时间内爆发出的粒子数，bursts设置粒子数时间间隔和周期

## 3.4. 方向变化的炊烟怎么做（偏移Y轴生成粒子）

脚本内调节Velocity over lifetime或者Force over Lifetime生命周期内的受力偏移

## 3.5. 水花和波纹怎么做

创建粒子系统》更换粒子系统材质》调整粒子系统参数
secne/rowing

## 3.6. 烟花效果怎么做：https://www.cnblogs.com/1138720556Gary/p/9302262.html

一种烟花粒子（创建粒子系统》用曲线控制烟花粒子的大小变化（在Partical Effect面板中设置烟花粒子生命周期，勾选Size over Lifetime并展开Size over Lifetime面板，用曲线来控制粒子在生命周期中的大小变化）》调整烟花的发射速率和形状》更换烟花粒子的材质》调节烟花粒子的初始寿命和颜色（上升阶段））》设计多种烟花粒子》调节子发射模块(Sub Emitters)，使粒子在出生、消亡、碰撞等三个时刻生成其他的粒子

# 4. 关节组件

## 4.1. Hinge Joint，Fixed Joint，Spring Joint，Character Joint，Configurable Joint分别是什么关节

铰链（把两个物体重合的部分束缚在一起），固定（将两个刚体束缚在一起，使两者之间的相对位置影院保持不变），弹簧（将两个刚体束缚在一起，使两者好像有一个弹簧连接一样），人物（配合Ragdoll玩偶插件使用），可配置关节（包含所有与关节相关的属性）

## 4.2. 门模型怎么做

Hinge Joint场景，用圆柱体和立方体实现门轴和门》分别添加刚体》给门轴添加铰链关节》冻结门轴所有方向的位置和旋转
ps：门和门轴是同层关系，但门和门轴有重合的部分，而铰链关节就是把两个物体重合的部分束缚在一起

## 4.3. 机械手怎么做

Catcher场景，搭建场景和UI》该添加刚体的添加刚体》给绳子添加弹簧关节，给绳子的所有子物体添加固定关节并设置被固定的物体》

# 5. 车轮碰撞器WheelCollider

## 5.1. 制作利用虚拟摇杆控制车辆的移动的步骤

搭场景》赛车模型添加刚体》四个车轮添加车轮碰撞器》调整车轮碰撞器，给车身添加碰撞器》添加虚拟摇杆》创建赛车控制脚本和车轮旋转控制脚本》添加摄像机跟随脚本》分别给木箱和油桶添加物理材质
WheelCollider.motorTorque 在轮轴上的马达扭矩。根据方向正或负。
WheelCollider.steerAngle转向角度，总是沿自身Y轴。
WheelCollider.rpm当前轮轴旋转速度，每分钟转速（只读）。
Quaternion.Euler 欧拉 返回一个旋转角度，绕z轴旋转z度，绕x轴旋转x度，绕y轴旋转y度（像这样的顺序）
设置物体位置我们都是给transform.position赋值，那么问题来了，设置物体的旋转角度，我们就顺势给 transform.rotation 赋值了，额，那么就错了，其实 transform.rotation 是一个四元数（Quaternion），他需要一个转化才能达到我们想要的角度。
Transform.rotation 旋转角度，变换的旋转，在世界坐标空间储存为四元数。Unity以四元数储存旋转角度。要旋转一个对象使用Transform.Rotate，使用Transform.eulerAngles以欧拉角设置旋转角度。 
转速的单位时每秒多少圈，换算成多少度直接乘360即可

# 6. 布料

## 6.1. Skinned Mesh Render蒙皮组件各属性的含义

## 6.2. Cloth布料组件各属性的含义

# 7. 力场

## 7.1. 什么是力矩https://www.zhihu.com/question/20260034?sort=created

## 7.2. 怎么给物体施加一个力矩

GetComponent<Rigibody>().AddTorque(Vector3.up);则物体绕着y轴从上往下看顺时针旋转
力（的）矩意义：描述作用力使物体绕着转动轴或支点转动的趋向，但力矩并不能改变物体的运动状态
定义：力矩的大小等于作用于杠杆的作用力乘以支点到力的垂直距离，方向等于作用于杠杆的作用力和支点到力的位移矢量的叉积方向
![](../图床/20200219171648516_16397.png)
单位：单位是牛顿-米，矢量
1对质量为1单位的物体施加1个单位的力矩：表示角速度和径向距离的乘积始终为1，相当于直接定义了这个物体的运动状态，但角速度的大小并不会随时间发生变化
AddTorque(Vector3.up)：使世界坐标系的Y轴与该物体的垂直面上的点，按照到垂直点的距离不同产生不同大小的角速度，距离越近，角速度的值越大(向心加速度a=rw2)

|      |
| ---- |
|      |

## 3D开发的常用技术
 1. 3D游戏常用的开发技术 2. 3D拾取
3. 日志与信息
4. 声音
5. 奔跑动画
6. GUI绘制下拉列表
1. 3D游戏常用的开发技术
          name
note
       两种添加天 空盒方法
1.windows》Rendering》LightSetting 2.给相机添加Skybox组件，添加天空材 质球
    3D拾取
触控监听，触控点和摄像机组成的射线，碰到物体，获取名称执行预定义事件
       播放视频
把Texture的子类的Movie方法放到对象上，或者在UI层，不使用插件Mobile Movie Texture时默认全屏播放
    动态字体
在相机上挂载GUI脚本
       重力加速度 传感器
Input.acceleration 上一次测量的设备在三维空间中的线性加速度(只读)。 x,y,z分别表示手机屏幕竖直、水平、垂直方向
        PlayerPrefs 类
信息的存储和提取，SetInt添加和GetInt输出，存档，分数..
        虚拟按钮与 摇杆
EasyTouch，安卓打包Platforms Android
        声音
音频管理器，音频监听器，Audio Source组件创建音频源，用滤波器控制音频效 果，Audio Mixer窗口混音器
     水特效
黑夜白天基本水和高级水，是否添加反射的shader，地形绘制，复杂
     雾特效
2. 3D拾取
14
15
16        {
17
18                {
19
混合已生成的像素的颜色和基于到镜头的距离来确定一个常量色实现，奔跑动画
   1 using UnityEngine;
2 using System.Collections;
3
4 public class Shiqu : MonoBehaviour {
5 public string touchname=null;//声明射线碰触到的物体名字变量
6 private GameObject gb;//声明游戏组成对象变量
7 private GameObject gbe;
8 private GameObject obj;
9 public GameObject objj;
10 private bool cubeflag=false;//声明一个标志位用来判断事件的发生
11      private bool sphereflag=false;
12      private bool Cylinderflag=false;
13 public Texture2D texture;//声明一个Texture2D变量
void Update () {
foreach (Touch touch in Input.touches)//对当前触控进行循环
if(touch.phase==TouchPhase.Began)//判断事件是否有触摸触发
Ray ray = Camera.main.ScreenPointToRay(touch.position);//声明有 一条由触控点和摄像机组成的射线
20
21
22 {
23 touchname = hit.transform.name;//获得射线碰触到物体的名称
24 SetText(touchname);//处理碰触触发事件
25 }
26 }
27 }
28
29
30 if(sphereflag)//如果sphereflag为真 31 {
32
33
置发生移动
34 }
35 if(cubeflag)//如果cubeflag为真 36 {
RaycastHit hit;//声明一个RayCastHit型变量hit
if (Physics.Raycast(ray, out hit))//判断此物理事件
gb.transform.Rotate(Time.deltaTime *100,0,0);//开始旋转物体 gb.transform.position = new Vector3(‐2.82f, ‐1.45f, 3.48f);//使物体位

 3. 日志与信息
    37
gbe.GetComponent<Renderer>().material.mainTexture = texture;//改变物
体的纹理图
38 }
39 if(Cylinderflag)//如果Cylinderflag为真 40 {
41 GameObject.Destroy(obj );//销毁该游戏对象
42 objj.SetActive(true);//显示另外一个游戏对象
43 }
44 }
45 void SetText(string cubename)//处理碰触触发事件 46 {
47 switch (cubename )
48 {
49
50
51
52
53
54
55
56
57
58
59
60
61 }
62
63 }
64 }
65
case "Cube"://如果碰触到的是Cube
gbe = GameObject.Find("Cube");//找到Scene中的Cube物体 cubeflag = true;//切换标志位
break;
case "Sphere"://如果碰触到的是Sphere
gb = GameObject.Find("Sphere");//找到Scene中的Sphere物体 sphereflag = true;
break;
case "Cylinder"://如果碰触到的是Cylinder
obj = GameObject.Find("Cylinder");//找到Scene中的Cylinder物体 Cylinderflag = true;
break;
    1 using UnityEngine;
2 using System.Collections;
3
4 public class PlayerPrefs_Demo : MonoBehaviour {
5 void Awake() {
6 PlayerPrefs.SetInt ("First",666);
7 PlayerPrefs.SetFloat ("Second",1.024f);
8 PlayerPrefs.SetString ("Thired","Hellow World");
9 PlayerPrefs.SetString ("Forth",WWW.EscapeURL("3D开发实战详解"));
10 Print ();
11                  PlayerPrefs.DeleteKey ("First");
    
 4. 声音
    12 Check ();
13                  PlayerPrefs.DeleteAll ();
14 Check ();
15          }
16          void Print()
17          {
18                  Debug.Log ("===========================");
19                  Debug.Log ("First Value is "+PlayerPrefs.GetInt("First"));
20                  Debug.Log ("Second Value is "+PlayerPrefs.GetFloat("Second"));
21                  Debug.Log ("Thired Value is "+PlayerPrefs.GetString("Thired"));
22                  Debug.Log ("Forth Value is "+WWW.UnEscapeURL(PlayerPrefs.GetStri
    ng("Forth")));
23                  Debug.Log ("===========================");
24          }
25          void Check()
26          {
27                  Debug.Log ("===========================");
28                  Debug.Log ("First is "+PlayerPrefs.HasKey("First"));
29                  Debug.Log ("Secong is "+PlayerPrefs.HasKey("Second"));
30                  Debug.Log ("Thired is "+PlayerPrefs.HasKey("Thired"));
31                  Debug.Log ("Forth is "+PlayerPrefs.HasKey("Forth"));
32                  Debug.Log ("===========================");
33 } 34 }
35
                  1
2
3
4
5
6{
7 music = this.transform.GetComponent<AudioSource> (); 8}
9 public void PressPlay()
10 {
11 if (!music.isPlaying) {
using UnityEngine;
using System.Collections;
public class PlayMusic : MonoBehaviour {
    AudioSource music;
public void Awake()
      12
13                  }
14          }
15          public void PressPause()
16          {
music.Play();
   
 5. 奔跑动画
    17                  if (music.isPlaying) {
 18
19                  }
20          }
21          public void PressStop()
22          {
23                  music.Stop ();
24          }
25  }
music.Pause();
       1 using UnityEngine;
2 using System.Collections;
3
4 public class Controler : MonoBehaviour {
5 public EasyJoystick MyJoystick;
6 CharacterController controller;
7 float RunSpeed;
8 Vector3 MoveDrection ;
9 public GameObject CameraA;
10 11
void Start () {
controller = (CharacterController)this.GetComponent("CharacterControlle
r");
14 }
12 13
controller.slopeLimit = 30.0f;
RunSpeed = 1000;
15 16 17 18
void Update () {
MoveDrection = new Vector3(Input.GetAxis("Fire1"), 0, 0);
MoveDrection = transform.TransformDirection(MoveDrection);
if (MyJoystick.JoystickTouch.y == 0 && MyJoystick.JoystickTouch.x == 0)
{
GetComponent<Animation>().Play("Laugh");
    GetComponent<Animation>().Play("Run");
19
20          }
21          if (MyJoystick.JoystickTouch.y > 0.5f) {
22
23          }
24          if (MyJoystick.JoystickTouch.x < ‐0.5f)
25          {
26              this.transform.Rotate(0, ‐1.0f, 0);
27          }
28          if (MyJoystick.JoystickTouch.x > 0.5f)
29          {
30              this.transform.Rotate(0, 1.0f, 0);

 6. GUI绘制下拉列表
    31          }
32          if (MyJoystick.JoystickTouch.y < ‐0.5f)
33          {
34              CameraA.transform.Translate(Vector3.back);
35          }
36          if(GetComponent<Animation>().IsPlaying("Run")){
     37
38          }
39          }
40  }
41
controller.SimpleMove(MoveDrection * (Time.deltaTime * RunSpeed));
     1 using UnityEngine;
2 using System.Collections;
3
4 public class Pop : MonoBehaviour {
5 private float Ypos1=0.0f;
6 private float Ypos2=0.0f;
7 private float Ypos3=0.0f;
8 private float Ypos4=0.0f;
9 private float Ypos5=0.0f;
10      private bool showDropdownButtons1 ;
11      private bool showDropButtonsUP1;
12      float dropSpeed   = 500.0f;
13      private string St="FogMode";
14      void Start() {
15 }
16      void Update(){
17          if(showDropdownButtons1 == true){
18              Ypos1 += Time.deltaTime * dropSpeed;
19              Ypos2 += Time.deltaTime * dropSpeed;
20              Ypos3 += Time.deltaTime * dropSpeed;
21              Ypos4 += Time.deltaTime * dropSpeed;
22              if(Ypos1 >= 60){
23
24              }
25              if(Ypos2 >= 120){
29
30 }
26
27              }
28              if(Ypos3 >= 180){
Ypos1 = 60;
Ypos2 = 120;
Ypos3 = 180;

   31              if(Ypos4 >= 240){
32
33 }
34              if(showDropButtonsUP1 == true){
35                  Ypos1 ‐= Time.deltaTime * dropSpeed;
36                  Ypos2 ‐= Time.deltaTime * dropSpeed;
37                  Ypos3 ‐= Time.deltaTime * dropSpeed;
38                  Ypos4 ‐= Time.deltaTime * dropSpeed;
39                  if(Ypos1 >= 0 || Ypos2 >= 0 || Ypos3 >= 0 || Ypos4 >= 0){
Ypos4 = 240;
40
41
42
43
44
45
46                  }
47              }
48 } 49 }
50
51
52
53
54                  }
55              }
56              if(showDropdownButtons1 == true){
57
58                  if (GUI.Button(new Rect(50, 0, 200, 60), St))
59                  {
60                      showDropButtonsUP1 = true;
61                      showDropdownButtons1 = false;
62                  }
63
64                  if (GUI.Button(new Rect(50, Ypos1, 200, 60), "Linear"))
65                  {
66                      showDropButtonsUP1 = true;
67                      showDropdownButtons1 = false;
68                      RenderSettings.fogMode = FogMode.Linear;
69                      St = "Linear";
70                  }
71                  if (GUI.Button(new Rect(50, Ypos2, 200, 60), "Exp2"))
72                  {
73
74                      showDropButtonsUP1 = true;
75                      showDropdownButtons1 = false;
76                      RenderSettings.fogMode = FogMode.ExponentialSquared;
77                      St = "Exp2";
78
Ypos1 = 0;
Ypos2 = 0;
Ypos3 = 0;
Ypos4 = 0;
showDropButtonsUP1 = false;
showDropdownButtons1 = false;
void OnGUI (){
    if(showDropdownButtons1 == false){
if (GUI.RepeatButton (new Rect (50, 0, 200, 60), St)){
    showDropdownButtons1 = true;

   79                  }
80                  if (GUI.Button(new Rect(50, Ypos3, 200, 60), "Exponential"))
81                  {
82
83                      showDropButtonsUP1 = true;
84                      showDropdownButtons1 = false;
85                      RenderSettings.fogMode = FogMode.Exponential;
86                      St = "Exponential";
87                  }
88                  if (GUI.Button(new Rect(50, Ypos4, 200, 60), "None"))
89                  {
90
91                      showDropButtonsUP1 = true;
92                      showDropdownButtons1 = false;
93                      RenderSettings.fogMode = 0;
94                      St = "None";
95                  }
96              }
97          }
98      }
99
        
## 光影效果--王薇植
|                               |                                                                                             |                |
| :---------------------------- | :------------------------------------------------------------------------------------------ | :------------- |
| Light组件的重要参数              | indirect multiplier间接乘数反射其他物体的光的系数，cookie,resolution，bias，draw halo，Culling Mask, |                |
| 点光源特点                      |                                                                                             | 从一点向四面八方 |
| 定向光源                       |                                                                                             |                |
| 聚光灯光源                      |                                                                                             |                |
| 区域光光源                      |                                                                                             |                |
| 发光材质                       |                                                                                             |                |
| 光照烘焙的步骤与参数             |                                                                                             |                |
| 法线贴图的使用与制作             |                                                                                             |                |
| 镜子开发                       |                                                                                             |                |
| 水面效果                       |                                                                                             |                |
| 其他高级功能                    |                                                                                             |                |
| 标准着色器，反射探头，全局光照技术 |                                                                                             |                |
## 模型与动画
|                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| :---------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 网格Mesh                | 1.通过Mesh类生成或修改物体的网格实现酷炫的物体变形特效2.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 使用Mesh使物体变形        | 1.为空对象添加网格过滤器组件》在网格过滤器中里设置网格数形Mesh》为另一个对象添加网格渲染器然后给其添加纹理》编写细分脚本添加到游戏对象上？                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Shatter Toolkit切割工具库 | 1.制作切割物体特效2.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 控制人物角色用刀砍石像     | 添加角色模型，给角色添加动画组件Animation，给角色添加角色控制器，刀光（给左右两个刀刃上的子对象添加拖尾渲染器）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 旧版动画系统             | 1.主要使用脚本控制动画播放2.两种导入：使用多个模型文件和使用动画分割技术导入动画3. 动画控制器组件Animation4.动画脚本：使用Animation类的Play方法播放指定名称的动画，使用CrossFade使动画模型在一定时间内淡入指定名称的动画并淡出其他动画来实现动画融合，使用AddMixingTransform方法将动画只应用给身体的一部分其他部分播放其他动画实现动画混合                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 旧版动画案例             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 角色动画的配置            | 1.创建骨骼结构映射-Avatar：选中人形角色模型文件，单击Rig，在animation Type里选择Humanoid并单击Apply按钮，则该模型文件已经被指定为人形角色模型2.配置Avatar：选中Avator文件，单击Configure Avatar，根据Avatar配置视口中的不同按钮就进行不同层次和部位的配置，当出现识别错误的场景和监视窗口时需要在Hierarchy视口中找到正确的骨骼，然后将正确的骨骼拖拽到Optional Bone下的指定位置如果拖拽的骨骼正确无误则所有骨骼都会变成绿色代表Avatar已经配置完成3.Muscle的配置：通过设置Avatar中的Muscle参数限制模型各个部位的运动范围：单击Avatar视口中的Muscles按钮进入Muscle的配置窗口，单击Upper Lrg Front-Back参数可以展开配置参数调整该骨骼的运动范围                                                                                                                                                            |
| 动画控制器的配置          | 1.每一个动画控制器都可以有若干个动画层，每个动画层都是一个动画状态机，动画状态机中可以同时包含若干个动画状态单元或子动画状态机2.动画状态单元的搭建：在动画控制器中右键Create State->Empty创建空动画状态单元，也可以将动画片段直接拖拽进动画状态机编辑窗口进行创建，将鼠标箭头当道动画状态单元上，右键选择Make Transition创建动画过渡条件，并再次点击在另一个动画状态单元上，完成动画过渡条件的连接(Mecanim动画系统通过动画过渡条件实现各个动画片段之间的逻辑)3.可以在任一非默认动画单元上右键选择Set As Default将其设置为默认动画4.过渡条件的参数设置：举例想游戏控制器添加一个Float类型的参数实现对游戏过渡条件的控制，点击Parameters视口中的+添加一个Float类型的参数，设置其初始值为-1.0，然后选中任意一个过渡条件，在检视窗口中的Conditions列表中点击+按钮添加参数控制，设置参数，为参数添加对比条件5.代码也可以对游戏控制器进行控制 |
| 角色动画的重定向          | 原理：利用Avatar文件充当模型骨骼架构与系统自带骨骼架构间的桥梁，重定向的模型骨骼架构都要通过Avatar与自带的骨骼架构搭建映射，映射后的模型骨骼会通过Avatar驱动系统自带骨骼运动，从而产生一套通用的骨骼动画，其他角色模型只需借助这套通用的骨骼动画，就可以做出与原模型相同的动作实现角色动画的重定向                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 创建动画混合树混合角色动画 | 1.打开动画控制器编辑窗口，右键Create State->From New Blend Tree创建一个角色动画混合树（本质上仍是一个动画状态单元，能将若干个动画混合成一个动画处理），进入混合树编辑窗口新建一个浮点型的参数用来控制动画混合，Mecanim动画系统会根据这个参数值的大小对该动画混合树进行配置，回到Insoector窗口将Parameter参数设置为刚才设置的浮点数的名字，在Motion列表的右下角添加+符号添加两个动画条目就可以将要混合的动画拖拽到其内了，摆放角色模型，将动画控制器拖拽给该模型对象的Animator组件即可2.动画混合树编辑窗口中的Blend Type下拉列表有多个选项可以设置角色动画的混合方式，不要试图通过混合树实现某段动画的关闭或开启，那样的功能只能通过搭建状态单元和过渡条件来完成                                                                                                                                                  |
| Mecanim中的代码控制       | 1.为动画状态机或动画状态单元添加继承于StateMachineBehaviour类的脚本，然后重写方法实现指定动画播放过程中的自定义操作2.通过代码生成动画控制器                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |

案例

1. 水的流动-控制物体的变形脚本-XiFen.cs
2. Shatter Toolkit的使用-控制角色移动和砍石像动画的播放，键盘控制角色移动和砍石像动画播放，砍石像时产生切割石像平面-EasyTouchDemo.cs,QieGe.cs,PengZhuang.cs
3. 旧版动画系统-控制任务模型播放角色动画-OldAnimation
4. 代码实现对游戏控制器的控制-StaticAniCtrl.cs
5. 角色动画重定向的应用-操作动画播放，动画按钮回调，实现摄像机对象的跟随-AniController.cs
6. 通过代码生成角色动画控制器-CreateController.cs，AniController.cs
7. 章末案例-实现对动画播放的控制-HeroController.cs



## 地形寻路与资源更新--范宇鹏
1.terrain Collider组件属于物理引擎方面，可实现地形的物理模拟计算，使挂载碰撞器的对象能与地形进行物理交互
2.raise and lower terrain和paint height按钮可以调整局部地形的高度，但后者会使设置高度低于最高高度
3.smooth height可以对尖锐处进行平滑处理
4.paint texture可以进行涂装上色，调整纹理比例粒子
5.力矩：改变物体转动方向
6.刹车力矩：与结合力矩方向相反
7.拖尾渲染器由材质、拖尾宽度、颜色、最小顶点距离组成
8.使用拖尾渲染器时，不能在游戏对象上使用其他渲染器
9.Materials:使用一个包含粒子着色器的材质，材质使用的贴图必需是平方尺寸
10.地形引擎将地形信息保存为一张高度图：可以将大量与地形有关的信息储存在一张空间占用非常小的灰度图上，同时可以在其他开发工具上设计好地形
11.Min Vertex Distance(最小顶点距离):较大的值将创建显示有更多锯齿的短，当使用较低的值拖尾时有一点点性能损失
12.最好使用粒子材质，达到更好的效果
13.自动寻路技术中，nav mesh agent组件可实现对指定对象自动寻路的代理移动过程中忽略一切碰体
14.off mesh link是为了满足复杂地形对生成导航网格的特殊需求提供的组件
15.从而实现自定义
16.nav mesh obstacle可实现英雄穿越人群而不被穿透
17.asserbundle是将资源unity提供的一种用于存储资源的压缩格式打包后的集合
18.buildassetbundles创建好后需要导出，此过程需要编写相应代码来实现
19.可通过缓存机制和非缓存机制下载assetbundle
20.热更新是在不停机的状态下进行更新，lua由标准c编写而成的小巧的脚本语言，lua语言体积小、速度快，能实现修正bug，修改游戏数据的目的
21.非缓存机制：创建一个WWW实例来下载assetbundle文件。需创建一个空对象，将其挂载
22.缓存机制：WWW类下的LoadFromCacheOrDownload接口来实现AssetBundle的下载。数据在缓存目录中不存在或者版本较低时，系统才会下载新的数据资源替换缓存中的原数据
23.examples是框架自带的demo例子，lua是框架自带的lua源码目录，用户的lua脚本放在这里，最后打包时，打包脚本会将其按目录结构生成到streaminassets目录里面去，然后放置到游戏的web服务器上，用于被每个游戏客户端下载更新他们本地的lua脚本，达到热更新的目的，plugins是ulua底层库所在的目录，scripts是框架的c#脚本层，streamassets是框架打包资源是生成的文件夹，将所有资源打包进该文件夹，ulua是
24.ulua/cstolua的核心目录第十章模型与动画
###Unity与建模软件单位的比例关系：
Unity默认的系统单位为m, 例如在Unity中新建一个Cube游戏对象，其长宽高都是一个单 位，即lm 。 但3D建模软件默认的系统单位并不都是 m, 为了让模型可以按照理想的尺寸导入 Unity, 就需要调整建模软件的系统单位或者尺寸。在3D建模软件中，应尽量使用 “米 ” 制单位。如果想要模型能够直接按照理想的尺寸导入Unity, 需要进行相关参数的设置。
###网格过滤器（Mesh Filter）
网格过滤器从资源中拿出网格并将其传递给网格渲染器，用于在屏幕上渲染。
该组件中有一个重要的属性“Mesh”，“Mesh”是网格过滤器实例化的Mesh，Mesh中有一些用于储存物体的网格数据的属性和生成或修改物体网格的方法。
网格包括顶点和多个三角形数组。
###Shatter Toolkit是用来制作一个切割物体的第三方插件，
###Mecanim 动画系统
1.创建骨骼结构映射一Avatar；
带动画的模型文件拖曳进Unity3D中时，系统会自动为模型文件生成一个Avatar文件作为其子对象，
2.配置Avatar；
3.Muscle的配置：
开发人员可能会遇到一些骨骼动画动作过于夸张的情况， 如果使用的是旧版动画， 就需要重新制作该动画。而Mecanim动画系统则为其提供了一套解决方案，读者可以通过设置Avatar中的Muscle参数， 来限制角色模型各个部位的运动范围， 防止某些骨骼运动范围超过合理值。

创建地形：Terrain，Terrain组件负责地形的基础功能，Terrain Collider组件充当了地形的物理碰撞器，单击Raise and Lower Terrain按钮然后鼠标点过的地形会凸起，同时按下Shift键可以实现下凹的功能，Paint Texture，Paint Details
灰度图（高度图）创建地形：灰度图制作，单击Terrain Settings按钮然后单击下方的Import Raw即可导入高度图
拖尾渲染器：属性有材质，拖尾宽度，拖尾颜色，最小顶点距离，使用时最好创建一个空白的游戏对象并附加拖尾渲染器Trail Renderer作为唯一的渲染器，然后就可以将想要跟随的任何物体设置为拖尾渲染器的父物体，材质最好使用粒子材质可以达到更好的效果，拖尾渲染器必须在一系列帧后显现，不能突然显现才能达到更加真实的效果，拖尾渲染器与其他粒子系统类似，会旋转为面向相机显示
汽车轮胎拖痕案例：创建地形和汽车，创建两个空对象使其位置正好分别在汽车后面两个轮胎与地面接触的地方，分别给两个空对象添加拖尾渲染器，然后将纹理图分别拖拽到这两个空对象上，然后设置两个空对象上的拖尾渲染器组件的参数，将这两个空对象拖拽到Car对象上使其成为Car对象的子对象，创建控制汽车移动的虚拟摇杆和实现摄像机跟随汽车移动，添加一个定向光源，调整其位置和角度，使其能够照亮场景
产生汽车刹车痕迹案例：新建场景，创建地形和汽车，导入公路模型，创建两个空对象并添加拖尾渲染器，设置两个空对象材质的着色器为Particles Multiply，创建控制汽车移动的虚拟摇杆和实现摄像机跟随汽车移动，编写实现汽车的刹车和控制刹车痕的产生并拖拽到主相机上
代理器-Nav Mesh Agent组件：实现对指定对象自动寻路的代理，NavMesh Walkable参数可对可使用导航网格层进行设置，使用2^n对导航层进行编号，值为3的代理器可在第0层和第1层上移动，其他层均无法使用
自定义路线-Off Mesh Link：开发人员可自行设计所需路线以满足复杂地形对生成导航网格的特殊需求，该路线会被并入指定的导航网格层中，与其他路线一并进行寻路计算。该组件挂载在一个对象上，同时需要指定另外两个对象来充当这个路线的起始点和目标点，程序员可获取产生的自定义路线上的name参数来判断当前正在穿越的路线
动态障碍物-Nav Mesh Obstacle:实现物体横穿人群而不被穿透的效果
自动寻路案例：新建场景，导入资源，新建地形，导入阴影包后把阴影资源作为玩家的子对象以产生阴影，选中map和Terrain对象，在Inspector面板中static下拉选中Navigation Static，使系统能在该对象的基础上生成导航网络，然后单击该窗口下的Bake按钮，进行导航网络的烘焙，生成的导航网络数据会被记录在Assets目录下新生成的Pathing文件夹下的NavMesh.asset上，给人物添加代理器组件并设置参数，为梯子添加自定义路线，调整两个路线子对象的位置使其产生一条弧线这条弧线所代表的路线会归并入对应的导航网格中，给hero挂载动画控制器并添加动画，开发摄像机的脚本（输入：英雄对象，导航代理器，棋子对象，移动步长，按钮0位置，按钮1位置，开始触摸位置，按钮0纹理，按钮1纹理，输出：实现监听脚本，触摸屏幕就可以实现摄像机视角的转换和寻路目标点的设置）
AssetBundle:可以存储任意一种Unity引擎可以识别的资源
AssetBundle的具体开发流程:创建AssetBundle，上传至服务器，下载AssetBundle，加载AssetBundle，卸载AssetBundle生成AssetBundle资源，生成Wrap文件(Gen Lua Wrap File子菜单？)供Lua调用,清除缓存，Controller和View文件夹，启动socket服务器
## 多线程与网络--李孟璐
多线程技术的基本知识、多线程技术用于大量计算、多线程技术在网络开发中的应用

1. 开启线程
2. 线程加锁
3. 线程休眠
4. 多线程用于大量计算
5. 多线程技术用于网络开发
网络类-Network
1. WWW类用于实现访问网络资源

基于Unity Network开发网络游戏
非授权服务器和授权服务器



# 1. 3D游戏常用的开发技术

| name               | note                                                         |
| :----------------- | :----------------------------------------------------------- |
| 两种添加天空盒方法 | 1.windows》Rendering》LightSetting 2.给相机添加Skybox组件，添加天空材质球 |
| 3D拾取             | 触控监听，触控点和摄像机组成的射线，碰到物体，获取名称执行预定义事件 |
| 播放视频           | 把Texture的子类的Movie方法放到对象上，或者在UI层，不使用插件Mobile Movie Texture时默认全屏播放 |
| 动态字体           | 在相机上挂载GUI脚本                                          |
| 重力加速度传感器   | Input.acceleration 上一次测量的设备在三维空间中的线性加速度（只读）。x,y,z分别表示手机屏幕竖直、水平、垂直方向 |
| PlayerPrefs类      | 信息的存储和提取，SetInt添加和GetInt输出，存档，分数..       |
| 虚拟按钮与摇杆     | EasyTouch，安卓打包Platforms Android                         |
| 声音               | 音频管理器，音频监听器，Audio Source组件创建音频源，用滤波器控制音频效果，Audio Mixer窗口混音器 |
| 水特效             | 黑夜白天基本水和高级水，是否添加反射的shader，地形绘制，复杂 |
| 雾特效             | 混合已生成的像素的颜色和基于到镜头的距离来确定一个常量色实现，奔跑动画 |

# 2. 3D拾取

```
using UnityEngine;
using System.Collections;

public class Shiqu : MonoBehaviour {
    public  string touchname=null;//声明射线碰触到的物体名字变量
    private  GameObject gb;//声明游戏组成对象变量
    private  GameObject gbe;
    private GameObject obj;
    public  GameObject objj;
    private bool cubeflag=false;//声明一个标志位用来判断事件的发生
    private bool sphereflag=false;
    private bool Cylinderflag=false;
    public Texture2D texture;//声明一个Texture2D变量
	void Update () {
        foreach (Touch touch in Input.touches)//对当前触控进行循环
      {
             if(touch.phase==TouchPhase.Began)//判断事件是否有触摸触发
              {
                  Ray ray = Camera.main.ScreenPointToRay(touch.position);//声明有一条由触控点和摄像机组成的射线
                  RaycastHit hit;//声明一个RayCastHit型变量hit
                  if (Physics.Raycast(ray, out hit))//判断此物理事件
                  {
                      touchname = hit.transform.name;//获得射线碰触到物体的名称
                      SetText(touchname);//处理碰触触发事件
                  }
              }
      }           
        
      
        if(sphereflag)//如果sphereflag为真
        {
            gb.transform.Rotate(Time.deltaTime *100,0,0);//开始旋转物体
            gb.transform.position = new Vector3(-2.82f, -1.45f, 3.48f);//使物体位置发生移动
        }
        if(cubeflag)//如果cubeflag为真
        {
            gbe.GetComponent<Renderer>().material.mainTexture = texture;//改变物体的纹理图
        }
        if(Cylinderflag)//如果Cylinderflag为真
        {
            GameObject.Destroy(obj );//销毁该游戏对象
            objj.SetActive(true);//显示另外一个游戏对象
        }
	}
    void SetText(string  cubename)//处理碰触触发事件
    {
        switch (cubename )
        {
            case "Cube"://如果碰触到的是Cube
                gbe  = GameObject.Find("Cube");//找到Scene中的Cube物体
                cubeflag = true;//切换标志位
                break;
            case "Sphere"://如果碰触到的是Sphere
                gb = GameObject.Find("Sphere");//找到Scene中的Sphere物体
                sphereflag = true;
                break;
            case "Cylinder"://如果碰触到的是Cylinder
                 obj   = GameObject.Find("Cylinder");//找到Scene中的Cylinder物体
                 Cylinderflag = true;
                 break;
        }
           
    }
}

```

# 3. 日志与信息

```
using UnityEngine;
using System.Collections;

public class PlayerPrefs_Demo : MonoBehaviour {
	void Awake() {
		PlayerPrefs.SetInt ("First",666);
		PlayerPrefs.SetFloat ("Second",1.024f);
		PlayerPrefs.SetString ("Thired","Hellow World");
		PlayerPrefs.SetString ("Forth",WWW.EscapeURL("3D开发实战详解"));
		Print ();
		PlayerPrefs.DeleteKey ("First");
		Check ();
		PlayerPrefs.DeleteAll ();
		Check ();
	}
	void Print()
	{
		Debug.Log ("===========================");
		Debug.Log ("First Value is "+PlayerPrefs.GetInt("First"));
		Debug.Log ("Second Value is "+PlayerPrefs.GetFloat("Second"));
		Debug.Log ("Thired Value is "+PlayerPrefs.GetString("Thired"));
		Debug.Log ("Forth Value is "+WWW.UnEscapeURL(PlayerPrefs.GetString("Forth")));
		Debug.Log ("===========================");
	}
	void Check()
	{
		Debug.Log ("===========================");
		Debug.Log ("First is "+PlayerPrefs.HasKey("First"));
		Debug.Log ("Secong is "+PlayerPrefs.HasKey("Second"));
		Debug.Log ("Thired is "+PlayerPrefs.HasKey("Thired"));
		Debug.Log ("Forth is "+PlayerPrefs.HasKey("Forth"));
		Debug.Log ("===========================");
	}
}

```

# 4. 声音

```
using UnityEngine;
using System.Collections;
public class PlayMusic : MonoBehaviour {
	AudioSource music;
	public void Awake()
	{
		music = this.transform.GetComponent<AudioSource> ();
	}
	public void PressPlay()
	{
		if (!music.isPlaying) {
			music.Play();
		}
	}
	public void PressPause()
	{
		if (music.isPlaying) {
			music.Pause();
		}
	}
	public void PressStop()
	{
		music.Stop ();
	}
}
```

# 5. 奔跑动画

```
using UnityEngine;
using System.Collections;

public class Controler : MonoBehaviour {
    public EasyJoystick MyJoystick;
    CharacterController controller;
    float RunSpeed;
    Vector3 MoveDrection ;
    public GameObject CameraA;
	void Start () {
        controller = (CharacterController)this.GetComponent("CharacterController");
        controller.slopeLimit = 30.0f;
        RunSpeed = 1000;
	}
	void Update () {
        MoveDrection = new Vector3(Input.GetAxis("Fire1"), 0, 0);
        MoveDrection = transform.TransformDirection(MoveDrection);
        if (MyJoystick.JoystickTouch.y == 0 && MyJoystick.JoystickTouch.x == 0) {
            GetComponent<Animation>().Play("Laugh");
        }
        if (MyJoystick.JoystickTouch.y > 0.5f) {
                GetComponent<Animation>().Play("Run");    
        }
        if (MyJoystick.JoystickTouch.x < -0.5f)
        {
            this.transform.Rotate(0, -1.0f, 0);
        }
        if (MyJoystick.JoystickTouch.x > 0.5f)
        {
            this.transform.Rotate(0, 1.0f, 0);
        }
        if (MyJoystick.JoystickTouch.y < -0.5f)
        {
            CameraA.transform.Translate(Vector3.back);
        }
        if(GetComponent<Animation>().IsPlaying("Run")){
            controller.SimpleMove(MoveDrection * (Time.deltaTime * RunSpeed));
        }
	}
}

```

# 6. GUI绘制下拉列表

```
    using UnityEngine;
    using System.Collections;

    public class Pop : MonoBehaviour {
    private float Ypos1=0.0f;
    private float Ypos2=0.0f;
    private float Ypos3=0.0f;
    private float Ypos4=0.0f;
    private float Ypos5=0.0f;
    private bool showDropdownButtons1 ;
    private bool showDropButtonsUP1;
    float dropSpeed   = 500.0f;
    private string St="FogMode";    
    void Start() {
    }
    void Update(){
        if(showDropdownButtons1 == true){
            Ypos1 += Time.deltaTime * dropSpeed;   
            Ypos2 += Time.deltaTime * dropSpeed;   
            Ypos3 += Time.deltaTime * dropSpeed;
            Ypos4 += Time.deltaTime * dropSpeed;
            if(Ypos1 >= 60){
                Ypos1 = 60;
            }
            if(Ypos2 >= 120){
                Ypos2 = 120;
            }
            if(Ypos3 >= 180){
                Ypos3 = 180;
            }
            if(Ypos4 >= 240){
                Ypos4 = 240;
            }
            if(showDropButtonsUP1 == true){
                Ypos1 -= Time.deltaTime * dropSpeed;
                Ypos2 -= Time.deltaTime * dropSpeed;
                Ypos3 -= Time.deltaTime * dropSpeed;
                Ypos4 -= Time.deltaTime * dropSpeed;
                if(Ypos1 >= 0 || Ypos2 >= 0 || Ypos3 >= 0 || Ypos4 >= 0){
                    Ypos1 = 0;
                    Ypos2 = 0;
                    Ypos3 = 0;
                    Ypos4 = 0;
                    showDropButtonsUP1 = false;
                    showDropdownButtons1 = false;  
                }
            }
        }
    }
        void OnGUI (){
            if(showDropdownButtons1 == false){
                if (GUI.RepeatButton (new Rect (50, 0, 200, 60), St)){
                    showDropdownButtons1 = true;
                }
            }
            if(showDropdownButtons1 == true){

                if (GUI.Button(new Rect(50, 0, 200, 60), St))
                {
                    showDropButtonsUP1 = true;
                    showDropdownButtons1 = false;
                }

                if (GUI.Button(new Rect(50, Ypos1, 200, 60), "Linear"))
                {
                    showDropButtonsUP1 = true;
                    showDropdownButtons1 = false;
                    RenderSettings.fogMode = FogMode.Linear;
                    St = "Linear";
                }
                if (GUI.Button(new Rect(50, Ypos2, 200, 60), "Exp2"))
                {

                    showDropButtonsUP1 = true;
                    showDropdownButtons1 = false;
                    RenderSettings.fogMode = FogMode.ExponentialSquared;
                    St = "Exp2";

                }
                if (GUI.Button(new Rect(50, Ypos3, 200, 60), "Exponential"))
                {
 
                    showDropButtonsUP1 = true;
                    showDropdownButtons1 = false;
                    RenderSettings.fogMode = FogMode.Exponential;
                    St = "Exponential";
                }
                if (GUI.Button(new Rect(50, Ypos4, 200, 60), "None"))
                {

                    showDropButtonsUP1 = true;
                    showDropdownButtons1 = false;
                    RenderSettings.fogMode = 0;
                    St = "None";
                }
            }
        }   
    }

```



# 着色器shader（unityshader入门精要部分）--季翔
[toc]

[Unity Shader学习笔记（8）纹理映射、凹凸映射](https://gameinstitute.qq.com/community/detail/120974)
[shader笔记](https://www.cnblogs.com/kanekiken/p/7616705.html)
[法线贴图及原理](https://blog.csdn.net/puppet_master/article/details/53591167)
[【Unity Shaders】Vertex & Fragment Shader入门](https://blog.csdn.net/candycat1992/article/details/40212735)
[谈谈 TANGENTA_SPACE_ROTATION](https://blog.lujun.co/2019/04/04/unity_shader_tangent_space_rotation/)
[Unity3D - Shader - 凹凸映射(Bump mapping)](https://blog.csdn.net/biezhihua/article/details/78628710)
[shader中的纹理贴图、透明度混合、顶点动画、后期特效处理等操作](https://www.cnblogs.com/zblade/p/6525939.html)
[CG函数tex2D()的详细解释](https://blog.csdn.net/yuanerjiang/article/details/88681589)
[从零开始制作一个Uber Shader（一）](https://zhuanlan.zhihu.com/p/84867268)
[ABOUTCG_法线贴图原理及烘焙完全教学](https://www.bilibili.com/video/av15525503?p=2)
[T1-Unity3d实现炫酷的角色登场效果 利用shader 小意思VR](https://www.bilibili.com/video/av85638570?p=2)
[Unity Shader系列教程](https://www.bilibili.com/video/av83116295?p=8)
[小意思VR](https://space.bilibili.com/359383100/favlist?fid=800428800&ftype=create)
## 基础部分与基础光照
Unity Shader基础
![740522badf1e3f03834f5e0ef427b4e0d00c441d?Expires=1587202506&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=YXRZD_v_images/20200418173348912_726144378.pngBGfL_v_images/20200418173348912_726144378.pngF_v_images/20200418173348912_726144378.pngFM5NHxAA78Q9nIShsD](_v_images/20200418173348912_726144378.png)![d00afbab6a7925bf3ee55c7580b925b402372839?Expires=1587202506&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=9MI4EFGQhMmv_v_images/20200418173413413_158995145.pngFvs1Sm0HWoU9y_v_images/20200418173413413_158995145.pngB0D](_v_images/20200418173413413_158995145.png)
基础
![9289fb85e231e39b1a485ddcd2a1409949070305?Expires=1587203055&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=9oUVpEjA9_v_images/20200418174034221_1643192266.pngBXWEDNE7ApV_v_images/20200418174034221_1643192266.pngFmCwvKgD](_v_images/20200418174034221_1643192266.png)
![a1ed1fdf258a7ffc281688ee318939f48357e4a0?Expires=1587203055&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=A3IEWi5NgIJVm2fn6H7tu_v_images/20200418174042242_492714242.pngBRTBmQD](_v_images/20200418174042242_492714242.png)
概述
![e8fd164971c5b20440975e499448ad96f39b6f35?Expires=1587203055&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=LtYf4WJJcAO6elYub2B12vcK3HoD](_v_images/20200418174050513_351322462.png)
形式
不论哪种方式，真正意义上的shader代码需要包含在shaderlab语义块中，如下所示：
![d00afbab6a7925bf3ee55c7580b925b402372839?Expires=1587203055&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=V4XYWmjgDWjVTsRGyXmMVaIiHzYD](_v_images/20200418174108196_1238006225.png)
![4f05371a619aa4391530c67bee561ec3665255af?Expires=1587203062&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=4EL_v_images/20200418174122985_201567792.pngBGu6FNUxdtK8cRpEB3FsFr_v_images/20200418174122985_201567792.pngFoD](_v_images/20200418174122985_201567792.png)
![d654e1b71b291abc5d550c5238b622d037d4e2ae?Expires=1587203062&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=iZ_v_images/20200418174135080_1168168825.pngBrfMf0aTKUft6m8jCfi9KnnZwD](_v_images/20200418174135080_1168168825.png)
![44e1d44109a428c8d22579481808969f8de138f3?Expires=1587203062&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=qxJm6b3tDP8S_v_images/20200418174140897_1117940901.pngBml_v_images/20200418174140897_1117940901.pngFTiTMWQtOqeAD](_v_images/20200418174140897_1117940901.png)
Unity Shader数学基础
笛卡尔坐标系
![635360226639eb9f2617f5d2fb194c9907a0e4a8?Expires=1587203063&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=_v_images/20200418174150710_898295504.pngBzPdzXmQ4Zzhcb1ioMGQxjCe_v_images/20200418174150710_898295504.pngBiUD](_v_images/20200418174150710_898295504.png)
三维笛卡尔坐标系
![6c349626d01894545c361d7f0dba00b3e6ac6965?Expires=1587203063&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=_v_images/20200418174157761_842497318.pngBbCUteKx9vxZYHn5aOBiQo7OWQkD](_v_images/20200418174157761_842497318.png)
点和矢量
![31938faf3a07b34771591349ffe10679737a03f3?Expires=1587203063&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=X3oGxUQiJpZ2W5eOKOl4fRUIW8ED](_v_images/20200418174209659_1492738955.png)
![adf215b83b80d78ea106936bc7a4749cea2baf44?Expires=1587203063&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=DchkKjrIlj1nJnCgmLq3ZwWAbMED](_v_images/20200418174217818_1559652431.png)
一些特殊矩阵
![ad5f9b340b7c03f1217d0e487809685b19a8b2d8?Expires=1587203064&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=B_v_images/20200418174228752_893012535.pngFhvDSDAORQOOUF1bvbcZ1GrXYYD](_v_images/20200418174228752_893012535.png)
![4dd6f338203e3b8f69a73b997bc8500f5a59ddcc?Expires=1587203064&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=gTZ1r4kl8Xf53nvX4GeAyp7kwtYD](_v_images/20200418174241306_98466862.png)
![f1958b72a865746a9707de10d9074012b51b4ad3?Expires=1587203065&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=36fw7FfWcYqe59PEk9lpn06biwUD](_v_images/20200418174250393_1370141444.png)

开始Unity Shader 
一个简单的着色器：
![74e1942057f831acb5a5dc32b3c95d788af6791b?Expires=1587203067&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=YJGIhertrxZzQjm0OvmuIDrsE9ID](_v_images/20200418174300201_500102527.png)
天空盒子：
![5f2fcb06664c4d15246150368045598ae281f5c6?Expires=1587203067&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=f9CPB684Fa338Iso4GofpqpVdskD](_v_images/20200418174310052_2119660578.png)
![9ee5ebc537ce38cbd07cfc583b65304a773b4936?Expires=1587203067&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=pTSgHgEAC6Z37_v_images/20200418174317456_529114363.pngF3O67oxh_v_images/20200418174317456_529114363.pngFt8O0wD](_v_images/20200418174317456_529114363.png)
![962d35b331b045fcabe0d9ec5661d1778d7d05f6?Expires=1587203067&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=Nl99TfNY_v_images/20200418174327632_95316714.pngFyF_v_images/20200418174327632_95316714.pngBWOc_v_images/20200418174327632_95316714.pngBB2UArpetVxsD](_v_images/20200418174327632_95316714.png)
使用纹理坐标访问纹理：

![0cf4f075849da03e55837320ae7683e378f3630f?Expires=1587203067&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=Q5Oif9VKqT6tETiFVeZHCbuoINcD](_v_images/20200418174336107_2112695183.png)

顶点着色器和片元着色器之间的通信：
![0cf4f075849da03e55837320ae7683e378f3630f?Expires=1587203067&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=Q5Oif9VKqT6tETiFVeZHCbuoINcD](_v_images/20200418174349501_1573321183.png)

在材质面板显示一个颜色拾取器，直接控制模型在屏幕上显示的颜色：
![08a1dfabcd16bb0fc22d3e7a27a88d4ae4e7bd50?Expires=1587203457&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=vgR04_v_images/20200418174604750_852520586.pngFw2Ho2khKFz62GtxkhaJSgD](_v_images/20200418174604750_852520586.png)
使用假彩色图像可视化一些模型数据：
![b3a76db0f845910c9383fee5ae431c207ec4ab4d?Expires=1587203457&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=h9RbCRoNbnF6yCSk3vNgwUNu0swD](_v_images/20200418174614448_302596118.png)
![6c3aa2f893f20523b92848689189993bb50c556b?Expires=1587203457&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=b6pUz2tPWRuARJYYKuo1NGNpkzoD](_v_images/20200418174622106_491679130.png)


定义复杂的变量类型
![4039f585f9991ce5b1f1324f46de043e26163a4f?Expires=1587203459&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=hSVrwH8z8kZVh6kT3z_v_images/20200418174632524_134064254.pngBVTBLqV84D](_v_images/20200418174632524_134064254.png)
Unity中的光照基础
图像呈现步骤：
![fc350c0629ccdce989c4b78058ddb42d3ef3dfe8?Expires=1587203459&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=IC8ORTbTEV3CIyN39Sb3vP0bWTcD](_v_images/20200418174639908_507571275.png)
光的吸收与反射：
![999ca2a6af2d2ba768c9e1e5cf64e0d156fb5575?Expires=1587203459&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=2jJnZOFrluff9ujo2tX6s6aAbbgD](_v_images/20200418174647519_945373041.png)
着色：
![c575bc161c7bf4b35d36d958b301898586fa440e?Expires=1587203462&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=dcEX7L2_v_images/20200418174655728_1800679581.pngFuvU5PEhGLCtoXdi_v_images/20200418174655728_1800679581.pngFCqgD](_v_images/20200418174655728_1800679581.png)
![dcfe91d9c26dc0f6b14f4b844a7cc9bf42be0e0f?Expires=1587203462&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=cf0xD7L9Xw2_v_images/20200418174702770_1682164343.pngBakbA4_v_images/20200418174702770_1682164343.pngFG5_v_images/20200418174702770_1682164343.pngF_v_images/20200418174702770_1682164343.pngBCtWjsD](_v_images/20200418174702770_1682164343.png)
四种发光形式：
![6fb61977c4273150c1a05d38e2a0a4fd3757f01d?Expires=1587203462&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=WUa1RQnAI5SRoF96NSTZC6aVU_v_images/20200418174709745_513900046.pngF0D](_v_images/20200418174709745_513900046.png)
实现漫反射光照模型：
![77daf8db5fffa85ff8ee7309a20d523a182348fc?Expires=1587203463&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=4TSH6SpDQhNdkCKshwzRJkQl4GgD](_v_images/20200418174719947_2086328535.png)
![90cb66831a7ca1e7fd432688fcc4eccd40dad314?Expires=1587203463&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=ZInHXkGYWlGcKT9RZF9CHpsmp38D](_v_images/20200418174732353_810699529.png)
![023cfdfa3b2ed502fb142094f2235a819a638dca?Expires=1587203463&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=TbJLZzbV5LilrNZBtwsKp8wtXLID](_v_images/20200418174744264_1790727335.png)
逐像素光照：
![05a01b0afe968dae75d990d33a861dd6aab783f1?Expires=1587203464&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=cz8pPgp83RV3kyW_v_images/20200418174753079_1918490287.pngF_v_images/20200418174753079_1918490287.pngFuxrGpII0tAD](_v_images/20200418174753079_1918490287.png)
实现高光反射光照：
![c8f5ad100803e1f67a0eea65d7ce67c450908569?Expires=1587203464&KSSAccessKeyId=AKLT8UsQHPqzQva5fTr3vvnN1g&Signature=6lLpaOYDrUAfoQVCV48zM9hKuYwD](_v_images/20200418174802725_1746777551.png)


//凹凸贴图为什么利用法线贴图本质：遍历这个模型所有的点，关键是利用这个点的法线方向来确定该点所在的平面的弯曲方向（这样就能匹配不同地方的凹凸了）；
//为什么使用切线空间而不使用模型空间（用模型空间的方向来确定顶点处的法线方向）的法线纹理：自由度高，使用的是相对的法线信息（法线扰动方向），换个模型也能使，进行UV动画，还是模型本身会发生变化，切线空间的构造比模型空间的构造通过省掉Z方向来压缩文件内存
//使用了法线贴图的物体在计算光照模型时是在切线空间下进行光照计算，还是在世界空间下进行光照计算
## 基础纹理
| 基础纹理                                                    |                                                                                                                                                                                 | 备注                                                                                                                                                                                                                                                                                                                                                                           |
| :--------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 纹理映射坐标                                                 | 1.UV坐标即纹理映射坐标它存储在每个顶点中，定义了该顶点在纹理中对应的2D坐标（建模师生成了一种3D模型所有顶点映射到一张2D Texture中的映射关系的文件，3D模型的顶点的坐标信息在这个文件中体现为一个个UV坐标）2. |                                                                                                                                                                                                                                                                                                                                                                               |
| 纹理的属性                                                   | Texture Type，Alpha from Grayscale，Wrap Mode，Filter Mode纹理变换拉伸时的滤波模式（缩放时的处理模式），Max Texture Size（最大分辨率，纹理长宽应为2的幂），Format纹理格式                         | 1.这三种滤波模式用来处理纹理放大，Point点式的（采用的像素数目只有一个，像素风），Bilinear双线的（常用，线性插值混合4个相邻像素，平滑但模糊），Trilinear三线的（Biliner基础上在多级渐远纹理之间进行线性擦至混合）2.多级渐远纹理技术用来处理纹理缩小（此时多个像素对应一个目标像素，需要处理抗锯齿问题）（advanced的纹理类型+General Mip Maps)(将纹理提前进行滤波处理，相机靠近使用较大纹理，相机远离使用较小纹理从而优化纹理计算时间） |
| 单张纹理（把颜色加到多边形上）                                  | 代替物体表面的漫反射颜色                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                               |
| 凹凸映射与法线纹理（把粗糙信息加到多边形上，负责光的方向的纹理映射） | 1.使用一张纹理修改模型表面的法线给模型提供更多细节，从而实现凹凸映射2.高度纹理使用一张高度图来实现凹凸映射，由像素灰度值得到表面法线3.用模型顶点的切线空间来存储法线（自由度更高并可以进行UV动画）         | 1.模型空间存储法线信息：2.切线空间存储法线信息：3.模型空间存储法线的优点：1.计算更少                                                                                                                                                                                                                                                                                                                                                 4.切线空间存储法线的优点：                                                                                                                                                                                                                                                                   |
| 渐变纹理                                                    |                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                               |
| 遮罩纹理                                                    |                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                               |
|                                                            |                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                               |
|                                                            |                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                               |
|                                                            |                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                               |
|                                                            |                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                               |
### 使用纹理代替物体的漫反射颜色
```
Shader "Unity Shader Book/Chapter 7/Single Texture"{  
    Properties{  
        _Color ("Color Tint", Color) = (1,1,1,1)  
        _MainTex("MainTex", 2D) = "white" {}  
        _Specular("Specular", Color) = (1,1,1,1)  //自发光颜色
        _Gloss("Gloss",Range(8.0,256)) = 20  //镜面反射系数
    }  
      
    SubShader{  
        Pass{  
            Tags {"LightMode" = "ForwardBase"}  
              
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
              
            #include "Lighting.cgnic"  
              
            fixed4 _Color;  
            sampler2D _MainTex;
            //与其他属性类型不同的是，我们还需要为纹理类型的属性声明一个float4类型  
            //的变量_MainTex_ST。其中，_MainTex_ST的名字不是任意起的。在Unity中，  
            //我们需要使用纹理名_ST的方式来声明某个纹理的属性。其中ST是缩放和平移的缩写。  
            //_MainTex_ST可以让我们得到该纹理的缩放和平移值  
            //_MainTex_ST.xy存储的是缩放值，_MainTex_ST.zw存储的是偏移值  
            float4 _MainTex_ST;  //这种有点像unity的内置变量，直接获取该纹理的缩放和平移值
            fixed4 _Specular; //自发光颜色属性代入
            float _Gloss;//镜面反射系数代入
           
            //顶点着色器的输入结构体  
            struct a2v{  
                float4 vertex : POSITION;  //模型空间中的顶点坐标
                float3 normal : NORMAL; //模型空间中的法线方向
                //unity会将模型的第一组纹理坐标存储到该变量中。  
                float4 texcoord : TEXCOORD0;  //存放该模型的第一组纹理坐标
            }  
              
            //顶点着色器的输出结构体  
            struct v2f{  
                float4 pos : SV_POSTION;  //裁剪空间中的顶点坐标
                float3 worldNormal : TEXCOORD0;  //输出第1组纹理坐标
                float3 worldPos : TEXCOORD1;  //输出第2组纹理坐标
                //用来存储纹理坐标  
                float2 uv : TEXCOORD2;  //输出第三组纹理坐标
            }  
              
            //顶点着色器  
            //在顶点着色器中，我们使用纹理的属性值_MainTex_ST来对顶点纹理坐标进行变换，  
            //得到最终的纹理坐标。计算过程是，首先使用缩放属性_MainTex_ST.xy对顶点纹理坐标  
            //进行缩放，然后再使用偏移属性MainTex_ST.zw对结果进行偏移  
            v2f vert(a2v v){  
                v2f o;  
                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);  //模型空间的坐标-》裁剪空间中的坐标
                o.worldNormal = UnityObjectToWorldNormal(v.normal);  //模型空间中的法线方向-》裁剪空间中的法线方向
                o.worldPos = mul(_Object2World, v.vertex).xyz; //把裁剪空间中的顶点坐标放到worldPos中
                o.uv = v.texcoord.xy * _MainTex_ST.xy + MainTex_ST.zw; //纹理坐标先缩放再偏移，这一步实现了把所有的顶点坐标按照所覆盖的纹理的要求先缩放再平移，从而实现了从纹理坐标到顶点坐标的映射
                //可以使用内置函数来代替  
                //o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);  
                return o;  
            }  
              
            fixed4 frag(v2f i) : SV_Target{  //输出值存储到渲染目标中
                //计算了世界空间下的法线方向和光照方向  
                fixed3 worldNormal = normalize(i.worldNormal); //把裁剪空间中的法线向量进行归一化 
                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));//模型空间中光线方向先转换到裁剪空间再进行归一化  
                //使用tex2D函数对纹理进行采样，第一个参数是需要被采样的纹理，第二个是float2类型的纹理坐标  
                //我们使用采样结果和颜色属性_Color的乘积来作为材质的反射率albedo，
                fixed3 albedo = tex2D(_MainTex,i.uv).rgb * _Color.rgb;//tex2D的返回值是贴图上对应的uv点的颜色，即找到模型上这个顶点在纹理贴图上的对应点的颜色
                //使用albedo来计算漫反射光照的结果，即表面的基本色
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;  //利用语义得到环境光部分
                  
                fixed3 diffuse  = _LightColor0.rgb * albedo * max(0,dot(worldNormal, worldLightDir));  
                  
                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));  
                fixed3 halfDir = normalize(worldLightDir + viewDir);  
                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal,halfDir)),_Gloss);  
                  
                return fixed4(ambient + diffuse + specular, 1.0);  
            }  
        }  
    }  
    Fallback "Specular"  
}  
```
### 在切线空间下计算光照模型
```
Shader "Unity Shaders Book/Chapter 7/Normal Map In Tangent Space"{  
    Properties{  
        _Color ("Color Tint", Color) = (1,1,1,1)  
        _MainTex("MainTex", 2D) = "white" {}  
        //法线纹理，使用"bump"作为默认值。  
        //"bump"是Unity内置的法线纹理，当没有提供任何法线纹理时，"bump"就对应了模型自带的法线信息。  
        _BumpMap("Normal Map", 2D) = "bump" {}  
        //_BumpScale是用于控制凹凸程度，0意味着该法线纹理不会对光照产生任何影响  
        _BumpScale("Bump Scale", Float) = 1.0  
        _Specular("Specular", Color) = (1,1,1,1)  //自发光颜色
        _Gloss("Gloss", Range(8.0, 256)) = 20  //镜面反射系数
    }  
      
    SubShader{  
        Pass{  
            Tags {"LightMode" = "ForwardBase"}  
              
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
              
            #include "Lighting.cgnic"  
              
            fixed4 _Color; //一个白色
            sampler2D _MainTex;//导入纹理贴图  
            float4 _MainTex_ST;//获得纹理贴图的缩放和偏移量  
            sampler2D _BumpMap;//存储法线纹理贴图 
            float4 _BumpMap_ST;//存储法线纹理贴图的缩放和偏移系数  
            float _BumpScale;  
            fixed4 _Spcular;//自发光颜色  
            float _Gloss;//镜面反射系数
              
            //顶点着色器输入结构体  
            struct a2v{  
                float4 vertex : POSTION;  
                float3 normal : NORMAL;  
                float4 tangent : TANGENT;//获取该顶点的切线  
                float4 texcoord : TEXCOORD0;//获取该顶点处的第一套纹理贴图  
            };  
              
            //顶点着色器的输出结构  
            struct v2f{  
                float4 pos : SV_POSTION;  
                float4 uv : TEXCOORD0;  
                float3 lightDir : TEXCOORD1;  
                float3 viewDir : TEXCOORD2;  
            };  
              
            //由于我们使用了两张纹理，因此需要存储两个纹理坐标。为此，我们把v2f中的uv变量  
            //的类型定义为float4，其中xy分量存储了_MainTex的纹理坐标，而zw分量存储了_BumpMap  
            //的纹理坐标。然后，我们把模型空间下的切线方向、副切线方向和法线方向按行排列来得到  
            //从模型空间到切线空间的变换矩阵 rotation。需要注意的是，在计算副切线时我们使用  
            //v.tangent.w 和叉积结果进行相乘，这是因为和切线与法线方向都垂直的方向有两个，而w  
            //决定了我们选择其中哪一个方向。  
            v2f vert(a2v v){  
                v2f o;  
                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);  
                  
                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;  
                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;  
                  
                  
                //float3 binormal = cross(normalize(v.normal),normalize(v.tangent.xyz)) * v.tangent.w;  
                //float3×3 rotation = float3×3(v.tangent.xyz, binormal,v.normal);  
                //以上代码可以用 TANGENT_SPACE_ROTATION 代替，//这个宏为我们定义好了模型空间到切线空间的转换矩阵rotation，注意后面有个；  
                  
                TANGENT_SPACE_ROTATION;  
                  
                //我们使用内置函数ObjSpaceLightDir 和 ObjSpaceViewDir 来得到模型空间下  
                //的光照和视角方向，再利用变换矩阵rotation把它们从模型空间变换到切线空间中  
                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;  
                o.viewDir = mul(rotation,ObjSpaceViewDir(v.vertex)).xyz;  
                  
                return o;  
            }  
              
            fixed4 frag(v2f i) : SV_Target{  
                fixed3 tangentLightDir = normalize(i.lightDir);  
                fixed3 tangentViewDir = normalize(i.viewDir);  
                //先利用tex2D对法线纹理_BumpMap 进行采样  
                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);  
                fixed3 tangentNormal;  
                  
                // If the texture is not marked as "Normal map"  
                //tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;  
                //tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));  
                  
                //Or mark the texture as "Normal map", and use the built-in function  
                tangentNormal = UnpackNormal(packedNormal);  
                //利用_BumpScale 控制凹凸程度  
                tangentNormal.xy *= _BumpScale;  
                //由于法线都是单位矢量，因此tangentNormal.z 可以由tangentNormal.xy计算而得  
                tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy,tangentNormal.xy)));  
                  
                fixed3 albedo = tex2D(_MainTex,i.uv).rgb * _Color.rgb;  
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;  
                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir));  
                  
                fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);  
                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(tangentNormal,halfDir)),_Gloss);  
                return fixed4(ambient + diffuse + specular, 1.0);  
            }  
            ENDCG  
        }  
    }  
    Fallback "Specular"  
}  
```
### 世界空间下计算光照模型
```
Shader "Unity Shaders Book/Chapter 7/Normal Map In World Space"{  
    Properties{  
        _Color ("Color Tint", Color) = (1,1,1,1)  
        _MainTex("MainTex", 2D) = "white" {}  
        _BumpMap("Normal Map", 2D) = "bump" {}  
        _BumpScale("Bump Scale", Float) = 1.0  
        _Specular("Specular", Color) = (1,1,1,1)  
        _Gloss("Gloss", Range(8.0, 256)) = 20  
    }  
      
    SubShader{  
        Pass{  
            Tags {"LightMode" = "ForwardBase"}  
              
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
              
            #include "Lighting.cgnic"  
              
            fixed4 _Color;  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            sampler2D _BumpMap;  
            float4 _BumpMap_ST;  
            float _BumpScale;  
            fixed4 _Spcular;  
            float _Gloss;  
              
            //顶点着色器输入结构体  
            struct a2v{  
                float4 pos : POSTION;  
                float4 uv : TEXCOORD0;  
                float4 TtoW0 : TEXCOORD1;  
                float4 TtoW1 : TEXCOORD2;  
                float4 TtoW2 : TEXCOORD3;  
            };  
              
            //顶点着色器的输出结构  
            struct v2f{  
                float4 pos : SV_POSTION;  
                float4 uv : TEXCOORD0;  
                float3 lightDir : TEXCOORD1;  
                float3 viewDir : TEXCOORD2;  
            };  
              
          
            v2f vert(a2v v){  
                v2f o;  
                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);  
                  
                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;  
                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;  
                //我们计算了世界空间下的顶点切线、副切线和法线的矢量表示，  
                //并把它们按列摆放得到从切线空间到世界空间的变换矩阵  
                float3 worldPos = mul(_Object2World,v.vertex).xyz;  
                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  
                fixed3 worldTangent = UnityObejctToWorldDir(v.tangent.xyz);  
                fixed3 worldBinormal = cross(worldNormal,worldTangent) * v.tangent.w;  
                  
                //然后把上述矩阵的每一行分别存储在TtoW0、TtoW1、TtoW2中，并把世界空间下  
                //的顶点位置的xyz分量分别存储再了这些变量的w分量中，以便充分利用插值寄存器的存储空间。  
                o.TtoW0 = float4(worldTangent.x,worldBinormal.x,worldNormal.x,worldPos.x);  
                o.TtoW1 = float4(worldTangent.y,worldBinormal.y,worldNormal.y,worldPos.y);  
                o.TtoW2 = float4(worldTangent.z,worldBinormal.z,worldNormal.z,worldPos.z);  
                  
                return o;  
            }  
              
            fixed4 frag(v2f i) : SV_Target{  
                float3 worldPos = float3(i.TtoW0.w,i.TtoW1.w,i.TtoW2.w);  
                fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));  
                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));  
                  
                fixed3 bump = UnpackNormal(tex2D(_Bump,i.uv.zw));  
                bump.xy *= _BumpScale;  
                bump.z = sqrt(1.0 - saturate(dot(bump.xy,bump.xy)));  
                bump = normalize(half3(dot(i.TtoW0.xyz,bump),dot(.TtoW1.xyz,bump),dot(.TtoW2.xyz,bump)));  
                  
                fixed3 albedo = tex2D(_MainTex,i.uv).rgb * _Color.rgb;  
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;  
                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(bump, lightDir));  
                  
                fixed3 halfDir = normalize(lightDir + viewDir);  
                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(bump,halfDir)),_Gloss);  
                return fixed4(ambient + diffuse + specular, 1.0);  
            }  
            ENDCG  
        }  
    }  
    Fallback "Specular"  
}  
```
### 实现渐变纹理
```
Shader "Unity Shaders Book/Chapter 7/Ramp Texture"{  
    Properties{  
        _Color("Color Tint", Color) = (1,1,1,1)  
        _RampTex("Ramp Tex", 2D) = "white" {}  
        _Specular("Specular", Color) = (1,1,1,1)  
        _Gloss("Gloss", Range(8.0, 256)) = 20  
    }  
    SubShader{  
        Tags {"LightMode" = "ForwardBase"}  
        CGPROGRAM  
        #pragma vertex vert  
        #pragma fragment frag  
          
        #include "Lighting.cgnic"  
          
        fixed4 _Color;  
        sampler2D _RampTex;  
        float4 _RampTex_ST;  
        fixed4 _Specular;  
        float _Gloss;  
          
        //顶点着色器的输入结构体  
        struct a2v{  
            float4 vertex : POSITION;  
            float3 normal : NORMAL;  
            float4 texcoord : TEXCOORD0;  
        };  
          
        struct v2f{  
            float4 pos : SV_POSTION;  
            float3 worldNormal : TEXCOORD0;  
            float3 worldPos : TEXCOORD1;  
            float2 uv : TEXCOORD2;  
        };  
          
        v2f vert(a2v v){  
            v2f o;  
            o.pos = mul(UNITY_MATRIX_MVP, v.vertex);  
            o.worldNormal = UnityObjectToWorldNormal(v.normal);  
            o.worldPos = mul(_Object2World, v.vertex).xyz;  
            //使用内置的TRANSFORM_TEX宏来计算经过平铺和偏移后的纹理坐标  
            o.uv = TRANSFORM_TEX(v.texcoord, _RampTex);  
            return o;  
        }  
          
        fixed4 frag(v2f i) : SV_Target{  
            fixed3 worldNormal = normalize(i.worldNormal);  
            fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));  
              
            fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;  
            //使用半兰伯特模型  
            fixed halfLambert = 0.5 * dot(worldNormal,worldLightDir) + 0.5;  
            //使用halfLambert来构建一个纹理坐标，并用这个纹理坐标对渐变纹理_RampTex进行采样  
            fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert,halfLambert)).rgb * _Color.rgb;  
              
            fixed3 diffuse = _LightColor0.rgb * diffuseColor;  
              
            fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));  
            fixed3 halfDir = normalize(worldLightDir + viewDir);  
            fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal,halfDir)),_Gloss);  
              
            return fixed4(ambient + diffuse + specular, 1.0);  
        }  
          
        ENDCG  
    }  
    Fallback "Specular"  
}  
```
### 遮罩纹理
```
Shader "Unity Shaders Book/Chapter 7/Mask Texture"{  
    Properties{  
        _Color("Color Tint", Color) = (1,1,1,1)  
        _MainTex("Main Tex",2D) = "white" {}  
        _BumpMap("Normal Map",2D) = "bump" {}  
        _BumpScale("Bump Scale",Float) = 1.0  
        //我们需要使用的高光反射遮罩纹理  
        _SpecularMark("Specular Mask",2D) = "white"{}  
        //用于控制遮罩影响度的系数  
        _SpecularScale("Specular Scale", Float) = 1.0  
        _Specular("Specular", Color) = (1,1,1,1)  
        _Gloss("Gloss",Range(8.0,256)) = 20  
    }  
      
    SubShader{  
        Pass{  
            Tags {"LightMode" = "ForwardBase"}  
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #include "Lighting.cgnic"  
              
            fixed4 _Color;  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            sampler2D _BumpMap;  
            float _BumpScale;  
            sampler2D _SpecularMark;  
            float _SpecularScale;  
            fixed4 _Specular;  
            float _Gloss;  
        }  
        struct a2v{  
        float4 vertex : POSITION;  
        float3 normal : NORMAL;  
        float4 tangent : TANGENT;  
        float4 texcoord : TEXCOORD0;  
        };  
          
        struct v2f{  
            float4 pos : SV_POSTION;  
            float2 uv : TEXCOORD0;  
            float3 lightDir : TEXCOORD1;  
            float3 viewDir : TEXCOORD2;  
        };  
          
        v2f vert(a2v v){  
            v2f o;  
            o.pos = mul(UNITY_MATRIX_MVP,v.vertex);  
            o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;  
              
            TANGENT_SPACE_ROTATION;  
            o.lightDir = mul(rotation,ObjSpaceLightDir(v.vertex)).xyz;  
            o.viewDir = mul(rotation,ObjSpaceViewDir(v.vertex)).xyz;  
              
            return o;  
        }  
          
        fixed4 frag(v2f i) : SV_Target{  
            fixed3 tangentLightDir = normalize(i.lightDir);  
            fixed3 tangentViewDir = normalize(i.viewDir);  
              
            fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv));  
            tangentNormal.xy *= _BumpScale;  
            tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy,tangentNormal.xy)));  
              
            fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;  
            fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;  
            fixed3 diffuse = _LightColor0.rgb*albedo*max(0,dot(tangentNormal,tangentLightDir));  
              
            fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);  
            //在计算高光反射时，我们首先对遮罩纹理_SpecularMark进行采样  
            //由于本例使用的遮罩纹理中每个纹素的rgb分量其实都是一样的，  
            //表面了该点对应的高光反射强度，在这里我们选择使用r分量来计算掩码值  
            fixed specularMask = tex2D(_SpecularMark,i.uv).r * _SpecularScale;  
            fixed3 specular = _LightColor0.rgb*_Specular.rgb*pow(max(0,dot(tangentNormal,halfDir)),_Gloss)*specularMask;  
            return fixed4(ambient + diffuse + specular, 1.0);  
        }  
          
    }  
    Fallback "Specular"  
      
}  

```

